{"meta":{"title":"Karakarua's blog","subtitle":"","description":"","author":"Ferrilata","url":"http://blog.kcaracal.com","root":"/"},"pages":[{"title":"关于","date":"2020-09-04T15:34:25.000Z","updated":"2020-09-04T15:34:25.000Z","comments":false,"path":"about/index.html","permalink":"http://blog.kcaracal.com/about/","excerpt":"","text":"BUPT 小伙子"},{"title":"404 Not Found：该页无法显示","date":"2020-09-04T15:34:25.000Z","updated":"2020-09-04T15:34:25.000Z","comments":false,"path":"/404.html","permalink":"http://blog.kcaracal.com/404","excerpt":"","text":""},{"title":"分类","date":"2020-09-04T15:34:25.000Z","updated":"2020-09-04T15:34:25.000Z","comments":false,"path":"categories/index.html","permalink":"http://blog.kcaracal.com/categories/","excerpt":"","text":""},{"title":"标签","date":"2020-09-04T15:34:25.000Z","updated":"2020-09-04T15:34:25.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.kcaracal.com/tags/","excerpt":"","text":""}],"posts":[{"title":"转载-数据结构与算法知识点思维导图","slug":"转载-数据结构与算法知识点思维导图","date":"2021-03-15T16:00:00.000Z","updated":"2021-03-16T05:05:03.618Z","comments":true,"path":"2021/03/15/fb2f8daaafda/","link":"","permalink":"http://blog.kcaracal.com/2021/03/15/fb2f8daaafda/","excerpt":"","text":"转自知乎如何系统地学习数据结构与算法？的数据结构与算法知识点思维导图： 其他：推荐一个算法相关的网站：算法网，网站内也包含一些其他的知识，如后端开发、移动开发、大数据等。","categories":[{"name":"Code","slug":"Code","permalink":"http://blog.kcaracal.com/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://blog.kcaracal.com/tags/Code/"}]},{"title":"docker常用命令","slug":"docker常见命令","date":"2021-03-09T16:00:00.000Z","updated":"2021-03-11T13:45:05.071Z","comments":true,"path":"2021/03/09/2d503f39a87f/","link":"","permalink":"http://blog.kcaracal.com/2021/03/09/2d503f39a87f/","excerpt":"","text":"镜像操作 docker pull IMAGE-NAME [:TAG] 从仓库拉取镜像，TAG表示镜像的版本，省略TAG表示拉取latest对应的版本的镜像 来自DockerHub的MySQL的截图： docker push IMAGE-NAME [:TAG] 将本地镜像上传到仓库 docker search KEYWORD 根据关键词搜索镜像 docker images [OPTION] [REPOSITORY [:TAG] ] 根据选项、仓库名称、版本，列出本地的镜像 OPTION : -a : 列出全部镜像 -f ：显示满足条件的镜像，How to use docker images filter -q : 只显示镜像ID REPOSITORY:TAG : 指定仓库名称和版本时列出本地镜像 docker rmi [OPTION] IMAGE1-NAME[:TAG] IMAGE2-NAME[:TAG] … OPTION : -f : 强制删除镜像（即时存在容器，也强制删除） 可以一次删除多个镜像 docker build [OPTION] PATH 利用Dockerfile自定义构建镜像 OPTION : -f : 指定使用的Dockerfile路径（可以用”.”表示当前路径） -t : 指定镜像名称及版本，格式 IMAGE-NAME[:TAG] Dockerfile文件的名称须是Dockerfile 容器操作 docker run [OPTION] IMAGE-NAME[:TAG] [COMMAND] 以某个镜像创建一个容器并运行容器（可指定初始命令） OPTION : -d 后台运行容器，返回为容器ID -it 以交互模式运行容器（-i：交互模式，-t：伪终端，二者常一起使用） -p 容器内端口映射到宿主机端口，格式为 宿主机端口:容器端口 -P 随机端口映射，容器内端口随机映射到宿主机端口 —name 指定容器名称 -e 指定环境变量（也可以在Dockerfile时通过ENV指定环境变量） —link 与其他容器建立单向通信， —link后跟的是容器名称，该选项实际是在本容器的/etc/hosts建立其他容器的解析 -v 挂在文件到容器内容，格式 宿主机路径: 容器内部路径 —dns 指定容器的dns服务器（也可以通过/etc/docker/daemon.json配置dns） —net 指定容器的网络类型，支持 bridge/host/none/container: 四种类型； —expose 开放一个或一组端口（也可以在Dockerfile动过EXPOSE指定开放的端口） —entrypoint 容器启动时的入口命令，该命令会覆盖Dockerfile中的ENTRYPOINT命令。 -w或者—workdir 指定工作目录（Dockerfile的最后一次WORKDIR会成为容器启动时的工作目录） COMMAND ：容器启动时的运行命令，如/bin/bash（该指令可以在Dockerfile中由CMD指定，run中指定的COMMAND会覆盖Dockerfile中的CMD） docker start/stop/restart IMAGE-NAME 启动、停止或重启容器 docker exec [OPTION] CONTAINER-NAME 进入容器内部 OPTION : -it 进入容器的交互模式，该选项一般是必须选项 docker crate [OPTION] IMAGE-NAME[:TAG] [COMMAND] 创建容器但不运行容器（OPTION同docker run，有时使用create创建一个共享容器) docker pause/unpause CONTAINER-NAME 暂停/恢复容器（注意pause是暂停容器， stop是停止容器） docker rm [OPTION] CONTAINER-NAME 删除容器 OPTION : -f ：强制删除容器（即便容器在运行状态） -v ：删除容器挂载的卷（挂载一般是为了使容器与外部连通，除非挂载卷无用才会删除挂载卷） docker ps [OPTION] 列出本地的容器 OPTION: -a 列出所有容器，包括未运行的容器（docker ps只列出运行状态的容器，加上-a是列出所有的容器而不管其是否运行） -l 列出最近创建的容器 -n 列出最近创建的n个容器 -s 显示容器大小（会多一列: SIZE) -q 只显示容器编号，安静模式 docker inspect [OPTION] NAME|ID 查看容器或者镜像的各种属性，如挂载、配置、IP等 OPTION : -s : 标准输出的参数中会显示大小信息（不加-s没有size信息） 可以使用容器或镜像的名称，也可以使用容器或镜像的编号 docker logs [OPTION] CONTAINER-NAME 获取容器内部日志 OPTION : -t 显示日志时间戳（不加-t，默认没有时间戳） —since 显示某个时间之后的日志 —tail 显示末尾N条日志 docker cp CONTAINER-NAME SRC:DST 从宿主机向容器拷贝数据 容器与镜像的备份与迁移 docker save [OPTION] IMAGE-NAME[:TAG] 将本地镜像保存为tar归档 OPTION : -o （必需命令）输出到文件（或者使用 &gt; , “&gt;”的含义是重定向至…） 可以一次写入多个镜像 docker load [OPTION] FILE 将镜像的tar归档文件加载为镜像 OPTION : -i （必需命令）指定输入的文件（或者使用&lt; ，”&lt;”的含义是从…重定向到此） -q 精简输出信息 可以载入多个镜像 docker export [OPTION] CONTAINER-NAME 将容器快照导出为tar文件 OPTION : -o （必需命令）内容输出指向的文件（或使用重定向”&gt;”） CAUTION: 使用export导出的镜像只是容器的快照，会失去历史记录、WORKDIR、ENTRYPOINT等信息 docker import [OPTION] FILE 将容器快照的tar归档文件加载为镜像 注意：恢复的镜像只是容器的快照镜像，没有历史记录及数据信息（WORKDIR、ENTRYPOINT等） docker load和docker import存在区别，准确说是save和export的区别，save会保存该镜像的的所有历史记录，而export只是保存容器的快照 docker commit [OPTION] CONTAINER-NAME [REPOSITORY[:TAG]] 从现有容器制作镜像 OPTION : -a 制作镜像的作者镜像属性中会包含Author信息，可通过inspect命令查看） -m 制作镜像的说明注释（镜像属性中会包含Comment信息，可通过inspect命令查看） commit不同于export，会保存容器的历史变更，即读写层内容 此小节相关链接： docker import和docker load的区别是什么？ docker：export/save/commit谁才是你心中那个她 Docker镜像与容器备份迁移（export、import与commit、save、load） docker网络管理：docker network COMMAND docker有四种网络类型，分别是bridge、host、none、container，可以简单理解为桥接模式（或是NAT模式）、主机模式、手动配置网络、共享容器网络，可参考的链接：Docker的网络概念与网络模式、Docker的四种网络模式Bridge模式 docker network ls [OPTION] 列出已有的网络类型 OPTION : -q 安静模式，只列出网络编号 docker network create [OPTION] NETWORK-NAME OPTION : -d, —drive 指定网络类型 —gateway 指定网关 —subnet 使用CIDR格式指定网络IP docker connect NETWORK-NAME CONTAINER-NAME 将容器连接到网络 也可以在容器启动时通过 —network 指定容器连接的网络 容器连接到网络，实际是为容器添加了一块新的网卡并连接到新的网络，可以在容器内部通过ifconfig查看（通过apt-get install net-tools安装ifconfig） docker disconnect [OPTION] NETWORK-NAME CONTAINER-NAME 将容器与网络断开连接 OPTION : -f 强制断开连接 docker inspect [OPTION] NETWORK-NAME 查看网络属性 OPTION : -v, —verbose 详细输出 docker network rm NETWORK-NAME 删除网络 docker network prune [OPTION] 删除无用网络 OPTION : -f : 强制删除，无需确认 借助容器生命周期记忆命令","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.kcaracal.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.kcaracal.com/tags/Docker/"}]},{"title":"docker基础","slug":"docker基础","date":"2021-03-07T16:00:00.000Z","updated":"2021-03-10T11:51:03.198Z","comments":true,"path":"2021/03/07/cce4c2665410/","link":"","permalink":"http://blog.kcaracal.com/2021/03/07/cce4c2665410/","excerpt":"","text":"前言 从物理机到容器化： 物理机时代：部署慢、成本高、资源浪费、难迁移、受制于硬件 虚拟机时代：系统级别的隔离，需要安装操作系统 容器化时代：应用层面的隔离，比虚拟机更灵活 (https://sm.ms/image/9oQpOKn17WV3afl) 容器化的应用场景： 标准化的迁移方式 统一的参数配置 自动化部署 应用集群监控 开发与运维沟通的桥梁 docker 安装 在centos上安装docker：Install Docker Engine on CentOS 在Ubuntu上安装docker：Install Docker Engine on Ubuntu docker镜像加速编辑 /etc/docker/daemon.json，加入以下内容（可以添加多个url，以逗号分隔）： 123456&#123; &quot;registry-mirrors&quot;:[ &quot;https://docker.mirrors.ustc.edu.cn/&quot;, &quot;https://hub-mirror.c.163.com/&quot; ]&#125; 其他加速地址可见链接：Docker 镜像加速 docker的基本概念（不专业的理解） 镜像、一种只读的文件系统，提供容器运行时所需的程序、库、资源、配置等文件。镜像不包含任何动态数据，其内容在构建之后也不会被改变。（不恰当的比喻，类似安装存在系统的镜像文件） 容器： 镜像运行时的实体，彼此之间相互隔离（不恰当的比喻，类似安装成功后的操作系统） 仓库：集中存储镜像的远程服务器。 docker的简单架构docker基于C/S架构，由server提供功能并接受 client 的请求，二者之间通过REST API通信（HTTP) 更复杂的架构细节可见链接：Docker1-架构原理及简单使用（终于把Docker讲明白了）","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.kcaracal.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.kcaracal.com/tags/Docker/"}]},{"title":"从暴力破解到动态规划解答题目连续子数组的最大和","slug":"从暴力破解到动态规划解答题目连续子数组的最大和","date":"2021-01-12T16:00:00.000Z","updated":"2021-03-10T12:34:44.722Z","comments":true,"path":"2021/01/12/166d8b96ee8b/","link":"","permalink":"http://blog.kcaracal.com/2021/01/12/166d8b96ee8b/","excerpt":"","text":"梳理一下自己从暴力破解到动态规划的整个过程，希望可以帮到大家。 解此题，最容易想到的思路就是暴力破解，但是时间复杂度至少会是$O(n^2)$，有两种写法： 1234567891011121314151617// 时间复杂度：O(n^3)class Solution &#123; public int maxSubArray(int[] nums) &#123; int max = Integer.MIN_VALUE; for(int i = 0;i &lt; nums.length;i++)&#123; for(int j = i;j &lt; nums.length;j++)&#123; // 计算sum(i,j) int sum = 0; for(int k = i;k&lt;j;k++) sum+=nums[k]; if(sum &gt; max) max = sum; &#125; &#125; return max; &#125;&#125; 12345678910111213141516// 时间复杂度：O(n^2)class Solution &#123; public int maxSubArray(int[] nums) &#123; int max = Integer.MIN_VALUE; for(int i = 0;i &lt; nums.length;i++)&#123; int sum = 0; for(int j = i;j &lt; nums.length;j++)&#123; //sum(i,j)=sum(i,j-1)+nums[j] sum += nums[j]; if(sum &gt; max) max = sum; &#125; &#125; return max; &#125;&#125; 无论那种暴力破解，过程中需要计算的子数组一定如下所列，其中$sum(i,j)$代表计算从$nums[i]$到$nums[j]$的元素之和，我们要找到最大的 $sum(i,j)$。 sum(0,0) sum(0,1) sum(1,1) sum(0,2) sum(1,2) sum(2,2) sum(0,3) sum(1,3) sum(2,3) sum(3,3) ….. … … …. 假如我们要以$O(n)$的时间复杂度优化算法，就需要进一步压缩计算。 观察上边这个表格，如果我们每次能在最右侧得到该行的最大值，然后再求这么多最大值的最大值，岂不就能在$O(n)$内计算出结果？ 行最大值 sum(0,0) dp[0] sum(0,1) sum(1,1) dp[1] sum(0,2) sum(1,2) sum(2,2) dp[2] sum(0,3) sum(1,3) sum(2,3) sum(3,3) dp[3] ….. … … …. dp[j] 表格每一行的子数组都是以某一值结尾，所以我们设$dp[j]$为以$j$ 结尾的子数组的最大值，如上面表格所示。$dp[j]$的最大值就是我们要的结果。 如何计算$dp[j]$呢？ 以$sum(0,3) 、 sum(1,3) 、 sum(2,3) 、 sum(3,3)$为例，我们思考一下怎么求四者最大值。 可以看到，四者同时包含$nums[3]$，比较四者哪个更大，其实就是比较$0、nums[2]、nums[1]+nums[2]、nums[0]+nums[1]+nums[2]$四者谁大谁小。 有没有发现规律？$nums[2]、nums[1]+nums[2]、nums[0]+nums[1]+nums[2]$这三者的最大值恰好就是dp[2]。所以，如果dp[2]&gt;0，dp[3]=dp[2]+nums[3]，否则，dp[3] = 0 + nums[3]。用公式表示就是： dp[j]=\\begin{cases} dp[j-1]+nums[j], & dp[j-1]>0 \\\\ nums[j], & dp[j-1]\\le 0 \\end{cases} 最后一步，就是对上面所有的$dp[j]$求最大值。所以，动态规划的代码如下： 12345678910111213141516171819class Solution &#123; public int maxSubArray(int[] nums) &#123; int[] dp = new int[nums.length]; dp[0]=nums[0]; for(int j = 1;j&lt;nums.length;j++)&#123; if(dp[j-1]&gt;0)&#123; dp[j] = dp[j-1]+nums[j]; &#125;else&#123; dp[j] = nums[j]; &#125; &#125; int max = Integer.MIN_VALUE; for(int i = 0;i&lt;dp.length;i++)&#123; if(dp[i]&gt;max) max = dp[i]; &#125; return max; &#125;&#125; 最基础的动态规划做法到这就结束了，关于动态规划的再优化，本文不再赘述。","categories":[{"name":"Code","slug":"Code","permalink":"http://blog.kcaracal.com/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://blog.kcaracal.com/tags/Code/"}]},{"title":"Python循环体内实现异步并发","slug":"Python循环体内实现异步并发","date":"2020-12-18T16:00:00.000Z","updated":"2021-03-13T12:16:37.431Z","comments":true,"path":"2020/12/18/78eee4d0e7ba/","link":"","permalink":"http://blog.kcaracal.com/2020/12/18/78eee4d0e7ba/","excerpt":"","text":"问题起源：循环体内无法实现异步。Python使用异步模块Asyncio实现多线程并发，一般方式是:12345678async def func(): # code... async def main(): await(func())if __name__ ==&#x27;__main__&#x27;: asyncio.run(main())但实验过程中有个需求，是让循环体的每次循环都作为一个并发线程产生并发。 这种情况下，每次循环使用await调用异步函数，无法实现需求中的并发需求。 asyncio程序如下： 123456789101112131415import timeimport asyncioasync def hello(): await asyncio.sleep(1) print(&#x27;Hello World:%s&#x27; % time.time())async def main(): start = time.time() for i in range(5): await(hello()) print(&quot;use time: %f s&quot; % (time.time()-start))if __name__ ==&#x27;__main__&#x27;: asyncio.run(main()) 程序结果： 123456Hello World:1608368438.992576Hello World:1608368439.9939594Hello World:1608368440.9950461Hello World:1608368441.9971309Hello World:1608368443.00034use time: 5.008629 s 程序运行时间是5秒，意味着并未达到异步的效果。 原因：整个for循环体是一个协程，协程切换时会挂起整个main协程。 解决办法：使用asyncio.gather()asyncio.gather()需要输入一个任务列表，gather会划分任务，并分组执行，因此可以应对for循环体内的异步。 完善后的代码： 123456789101112131415import timeimport asyncioasync def hello(): await asyncio.sleep(1) print(&#x27;Hello World:%s&#x27; % time.time())async def main(): tasks=[] for i in range(5): tasks.append(hello()) await asyncio.gather(*tasks)if __name__ ==&#x27;__main__&#x27;: asyncio.run(main()) 程序运行结果： 123456Hello World:1608368546.8756351Hello World:1608368546.8756351Hello World:1608368546.8756351Hello World:1608368546.8756351Hello World:1608368546.8756351use time: 1.002837 s 程序运行时间是1秒，说明已经达到异步效果。 参考：异步编程 101：asyncio中的 for 循环 python中的asyncio使用详解 Python中的asyncio代码详解","categories":[{"name":"Concurrency","slug":"Concurrency","permalink":"http://blog.kcaracal.com/categories/Concurrency/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.kcaracal.com/tags/Python/"},{"name":"Concurrency","slug":"Concurrency","permalink":"http://blog.kcaracal.com/tags/Concurrency/"}]},{"title":"Java 优先队列自排序时机","slug":"Java-优先队列自排序时机","date":"2020-10-25T13:41:48.000Z","updated":"2020-10-25T14:33:28.000Z","comments":true,"path":"2020/10/25/364db06a3c43/","link":"","permalink":"http://blog.kcaracal.com/2020/10/25/364db06a3c43/","excerpt":"","text":"今天做算法题，使用到了优先队列数据结构——PriorityQueue，但忘记了它发生自动排序的时机，记录一下。 结论：优先队列只有在元素个数发生变化时才发生自排序，如果只是改变已有元素内容，并不能引发自排序。 实例证明： 优先队列元素类，自定义MC类，包含两个属性，编号No和时间aTime。 12345678910class MC &#123; int No; int aTime; MC(int no, int atime) &#123; No = no; aTime = atime; &#125;&#125; 使用优先队列，自定义优先级规则：先按aTime从小到大排序，再按No从小到大排序 1234567891011121314151617181920212223242526class Solution4 &#123; public static void main(String[] args) &#123; Queue&lt;MC&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;MC&gt;() &#123; @Override public int compare(MC o1, MC o2) &#123; System.out.println(&quot;--Sort--&quot;); if (o1.aTime &lt; o2.aTime) return -1; else if (o1.aTime == o2.aTime) &#123; return o1.No - o2.No; &#125; else return 1; &#125; &#125;); for (int j = 1; j &lt;= 3; j++) &#123; System.out.println(&quot;insert:&quot; + j); queue.offer(new MC(j, 0)); queue.stream().forEach(e -&gt; System.out.println(&quot;&lt;&quot; + e.No + &quot;,&quot; + e.aTime + &quot;&gt;&quot;)); &#125; System.out.println(&quot;change peek&quot;); queue.peek().aTime = 5; queue.stream().forEach(e -&gt; System.out.println(&quot;&lt;&quot; + e.No + &quot;,&quot; + e.aTime + &quot;&gt;&quot;)); &#125;&#125; 结果： 123456789101112131415insert:1&lt;1,0&gt;insert:2--Sort--&lt;1,0&gt;&lt;2,0&gt;insert:3--Sort--&lt;1,0&gt;&lt;2,0&gt;&lt;3,0&gt;change peek&lt;1,5&gt;&lt;2,0&gt;&lt;3,0&gt; 可以看到，当新元素插入时，会引发优先队列自排序。 但是只修改内部元素对象时，却不会引发优先队列自排序（没有将aTime最大的移动到队尾）。 优先队列添加元素源代码：1234567891011public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length) grow(i + 1); siftUp(i, e); //这里就是调整堆排序 size = i + 1; return true;&#125;","categories":[{"name":"Code","slug":"Code","permalink":"http://blog.kcaracal.com/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://blog.kcaracal.com/tags/Code/"}]},{"title":"pip更换国内源","slug":"pip更换国内源","date":"2020-10-06T08:20:04.000Z","updated":"2021-03-13T12:15:47.711Z","comments":true,"path":"2020/10/06/2c643ed1b59a/","link":"","permalink":"http://blog.kcaracal.com/2020/10/06/2c643ed1b59a/","excerpt":"","text":"感谢博客pip换源一行命令直接搞定 关键命令： 123pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple# 返回结果：# Writing to /home/xxx/.config/pip/pip.conf ​ 其中pip根据你使用的pip版本，Python2对应pip，Python3对应pip3 临时使用源： 1pip install xxx -i https://pypi.tuna.tsinghua.edu.cn/simple 建议全局更换pip源，方便日后使用。 各大知名国内源： 阿里云 http://mirrors.aliyun.com/pypi/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/","categories":[{"name":"Misc","slug":"Misc","permalink":"http://blog.kcaracal.com/categories/Misc/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.kcaracal.com/tags/Python/"}]},{"title":"大厂笔试题1——小强去买东西的概率","slug":"阿里笔试题1——和为奇数的概率","date":"2020-09-22T12:31:00.000Z","updated":"2020-11-11T14:45:02.000Z","comments":true,"path":"2020/09/22/118d0a70269e/","link":"","permalink":"http://blog.kcaracal.com/2020/09/22/118d0a70269e/","excerpt":"","text":"题目记不清楚了，大致题意为： 小强和小丽两人划拳决定谁去买东西。小强从1~N中随机取一个数，小丽从1~M中随机取一个数，如果两个数之和为奇数，则小强去买东西；否则小丽去买东西。问小强去买东西的概率是多少？请用最简分数的形式返回该概率。 示例：N=2, M=3，则小强可以选择的数字范围是1、2， 小丽可以选择的数字范围是1、2、3，所有可能的数字组合有(1,1)、(1,2)、(1,3)、(2,1)、(2,2)、(2,3)。其中和为奇数的组合是(1,2)、(2,1)、(2,3)；和为偶数的组合是(1,1)、(1,3)、(2,2)。所以概率是3/6，即1/2。返回结果1/2。 解答： 定义小强的号码牌为 $i$ ,则 $i=1,2…N$ ，定义小丽的号码牌为 $j$ ,则 $j=1,2…M$ 。首先，组合$(i,j)$的数量一共是$M*N$，我们记为$total$ 不妨从小强的角度考虑，对每个 $i$ 值，组合$(i,j)$的和分布在区域$[i+1, M+i]$，则这个范围内包含的奇数的个数是$\\lfloor \\frac{M+i+1}{2} \\rfloor - \\lfloor \\frac{i+1}{2} \\rfloor$ 。（原因：数字范围$[1,X]$内奇数的个数为$\\lfloor \\frac{X+1}{2} \\rfloor$。） 所以，和为奇数的组合个数是$\\sum^{N}_{i=1} \\lfloor \\frac{M+i+1}{2} \\rfloor - \\lfloor \\frac{i+1}{2} \\rfloor$ ，我们记作$odd$ 所求概率$p=\\frac{odd}{total}$ 题目要返回最简分数，所以要求$odd$和$total$的最大公约数，然后分子分母都除以最大公约数，就是结果。 代码如下： 123456789101112131415161718192021222324import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNextInt())&#123; int N = sc.nextInt(); int M = sc.nextInt(); int odd = 0; for(int i = 1;i&lt;=N;i++)&#123; // java的除会自动向下去整 odd += (M+i+1)/2 - (i+1)/2; &#125; int total=M*N; int factor = gcd(odd, total); System.err.printf(&quot;%d/%d\\n&quot;, odd/factor,total/factor); &#125; &#125; // 求最大公约数 public static int gcd(int a, int b)&#123; if(b==0) return a; else return gcd(b,a % b); &#125;&#125;","categories":[{"name":"Code","slug":"Code","permalink":"http://blog.kcaracal.com/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://blog.kcaracal.com/tags/Code/"}]},{"title":"Hexo渲染LaTeX公式","slug":"Hexo渲染LaTeX公式","date":"2020-09-19T09:19:15.000Z","updated":"2020-09-20T14:53:48.000Z","comments":true,"path":"2020/09/19/50a5bc49a87d/","link":"","permalink":"http://blog.kcaracal.com/2020/09/19/50a5bc49a87d/","excerpt":"","text":"感谢博客：在Hexo中渲染MathJax数学公式、Hexo博客中使用Latex、在Hexo中渲染MathJax数学公式 Hexo渲染LaTeX公式关键Hexo渲染主题的两个重要因素：mathjax和kramed，前者是数学公式渲染引擎，后者是Hexo的markdown渲染引擎，hexo默认渲染引擎是marked，但是它不支持mathjax，因此需要替换引擎。 一、Hexo添加mathjax 如果hexo安装有hexo-math,需要先卸载它。卸载命令： 1npm uninstall hexo-math --save 安装mathjax，安装命令： 1npm install hexo-renderer-mathjax --save hexo主题开启mathjax： 进入主题目录，编辑_config.yml，开启mathjax： 1234# MathJax Supportmathjax: enable: true per_page: true hexo博客开启mathjax： 博客文章的开头加入mathjax:true，具体如下： 12345---title: Hexo渲染LaTeX公式关键date: 2020-09-30 22:27:01mathjax: true-- 二、hexo切换kramed引擎 卸载marked引擎 1npm uninstall hexo-renderer-marked --save 安装kramed引擎 1npm install hexo-renderer-kramed --save 修改引擎bug 修改文件/node_modules\\kramed\\lib\\rules\\inline.js中escape和em两行，具体修改如下： 12// escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/, escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/, 这一步是在原基础上取消了对\\,{,}的转义(escape)。 同时把第20行的em变量也要做相应的修改。 12// em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 重新启动hexo: 1hexo clean &amp;&amp; hexo g -d 问题得到解决。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog.kcaracal.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.kcaracal.com/tags/hexo/"}]},{"title":"Leetcode 11 盛最多水的容器","slug":"Leetcode-11-盛最多水的容器","date":"2020-09-05T04:00:22.000Z","updated":"2020-09-22T12:32:34.000Z","comments":true,"path":"2020/09/05/ad3e8ec3f0f6/","link":"","permalink":"http://blog.kcaracal.com/2020/09/05/ad3e8ec3f0f6/","excerpt":"","text":"题目链接：11. 盛最多水的容器 解答对任意$(i,j)$组合，面积$area=min(height[i],height[j])*(j-i)$ 方法一：暴力搜索遍历所有$(i,j)$，代码： 12345678910111213class Solution &#123; public int maxArea(int[] height) &#123; int n = height.length; int res=0; for(int i =0;i&lt;n;i++)&#123; for(int j =0;j&lt;i;j++)&#123; int T=Math.min(height[i],height[j])*(i-j); res = Math.max(res,T); &#125; &#125; return res; &#125;&#125; 时间复杂度：$O(N^2)$，空间复杂度：$O(1)$ 方法二：双指针 定义左右指针$i$和$j$，分别代表容器的左右边界。 指定两个指针移动状态： 原则： 两个指针只会向内收缩，即$i$只能增大，$j$只能减小 指针的移动朝着area可能增大的方向移动 移动方法：取二者高度较小的向内收缩。 原因： 高度较大的向内收缩，$area$只会不变或者减小，因为$min(height[i],height[j])$要么不变，要么减小，并且$(j-i)$变小了。 高度较小的向内收缩，$area$可能会变大，因为$min(height[i],height[j])$可能会变大，尽管$(j-i)$变小，但综合$area$存在变大的可能性。（这里说可能变大，也存在变小的可能，就是高度较小的，它更小了） 相比于暴力搜索忽略的$(i,j)$的状态都是比$area$小的，不必重复计算 代码： 123456789101112class Solution &#123; public int maxArea(int[] height) &#123; int i=0,j=height.length-1,res=0; while(i&lt;j)&#123; int area=Math.min(height[i],height[j])*(j-i); res=Math.max(res,area); if(height[i]&lt;height[j]) i++; else j--; &#125; return res; &#125;&#125; 时间复杂度：$O(N)$，空间复杂度：$O(1)$","categories":[{"name":"Code","slug":"Code","permalink":"http://blog.kcaracal.com/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://blog.kcaracal.com/tags/Code/"}]},{"title":"Deepin零散记录","slug":"Deepin零散记录","date":"2020-09-04T16:09:48.000Z","updated":"2020-09-04T16:10:43.000Z","comments":true,"path":"2020/09/04/5c2cdfe509d5/","link":"","permalink":"http://blog.kcaracal.com/2020/09/04/5c2cdfe509d5/","excerpt":"","text":"有新发现就更新。 本人是deepin v20。deepin的tty1默认是图形界面，而一般Xorg默认在tty7。原因解释见论坛：请问15.5是默认tty1是图形界面么？ 官方回答: 目前默认是tty1， 原因是为了同plymouth(启动画面)使用的tty1，进行无缝自然过渡。也就是Xorg和plymouth直接使用同一个tty，避免创建新的tty造成进入X11那一瞬间的黑屏现象。 Deepin深度影院无法打开的问题来自论坛解答 深度影院无法打开，关闭深度影院的硬件加速即可。1gsettings set com.deepin.deepin-movie composited &#x27;DisableComposited&#x27; IDEA最近总是莫名其妙卡死的原因：搜狗输入法最新版——“搜狗输入法个人版v2.3.2”需要背锅，详细见论坛贴：[搜狗输入法个人版]goland和IDEA直接卡死，无法正常使用 deepin星火商店有个AppImage转Deb的转换器，转换到*.deb，就能让软件安装到系统，不用再便携式运行了。另外论坛发现帖子：请问AppImage .snap .deb Flatpak 区别","categories":[{"name":"Deepin","slug":"Deepin","permalink":"http://blog.kcaracal.com/categories/Deepin/"}],"tags":[{"name":"Deepin","slug":"Deepin","permalink":"http://blog.kcaracal.com/tags/Deepin/"}]},{"title":"(Windows-Linux)Spring Boot启动异常：Sprint-Boot-Tomcat--An-incompatible-version-[1-x-x]-o","slug":"(Windows-Linux)--Sprint-Boot-Tomcat--An-incompatible-version-[1-x-x]-o","date":"2020-09-03T16:00:00.000Z","updated":"2021-03-13T08:21:26.163Z","comments":true,"path":"2020/09/03/6bc02d38245f/","link":"","permalink":"http://blog.kcaracal.com/2020/09/03/6bc02d38245f/","excerpt":"","text":"情景：启动spring-boot项目，报错 An incompatible version [1.2.12] of the Apache Tomcat Native library is installed, while Tomcat requires [1.2.14]。原因：spring-boot内置tomcat要求的native库版本和本地native库版本不一致，需要升级。解决办法： Windows： 方法一：下载安装对应版本native库，文件一般是tcnative-1.dll，把它安装到C:\\Windows\\System32目录下覆盖原来的tcnative-1.dll。一般百度这个错误搜到的教程都是针对Windows平台的，比较好处理。这个不再赘述，给个教程链接：An incompatible version [1.2.12] of the APR based Apache Tomcat Native library is installed, while Tomcat requires version [1.2.14] 方法二：源码编译安装该native库。首先下载所需要的native库源码文件。链接地址为：http://archive.apache.org/dist/tomcat/tomcat-connectors/native/1.2.14/source/。下载/tomcat-native-1.2.14-win32-src.zip。然后解压后按照官方给定的教程编译安装。官方教程地址：http://archive.apache.org/dist/tomcat/tomcat-connectors/native/1.2.14/source/ Linux: 暂时没有找到Linux下比较方便安装native库的方式，因此只能以源码方式编译安装该native库，不过步骤也不麻烦。 参考教程：Linux下Springboot解决APR based Apache Tomcat Native library提示 ；官方教程 首先下载对应版本native库源码，下载source/tomcat-native-1.2.14-src.tar.gz，解压。 执行如下命令： sudo apt-get autoremove libtcnative-1 #删除安装的库cd native./configure —with-apr=/usr/bin/apr-1-configsudo makesudo make install 重新运行spring-boot项目一般就不再报错误了。完毕。","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/categories/Java-Web/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://blog.kcaracal.com/tags/Spring-Boot/"}]},{"title":"小记——Vuex实现前端拦截","slug":"Vuex实现前端拦截小记","date":"2020-09-03T16:00:00.000Z","updated":"2021-03-13T08:21:43.356Z","comments":true,"path":"2020/09/03/51a6c676d0fa/","link":"","permalink":"http://blog.kcaracal.com/2020/09/03/51a6c676d0fa/","excerpt":"","text":"之前讲过后端拦截的实现，后端拦截与前端拦截的区别：发生拦截的位置不同，一个在后端，一个在前端。后端拦截时请求肯定是已经到达了服务端，后端已经要做处理了。后端拦截的逻辑是对session判断，是否包含用户信息，没有就执行重定向请求，方法是response.sendRedirect(“/xxx”)，这个过程一直是后端在操纵，最后返回给浏览器。前端拦截是前端框架分别利用状态管理和路由，判断登录状态和重定向请求，比如Vue.js利用Vuex保存一个浏览器用户状态，当用户状态是未登录时，使用vue-router重定向到&quot;/login&quot;。这个过程是发生在前端的，只有必须要请求后端时才向服务端发送请求(&quot;/login&quot;)。前端拦截的实现代码来自博客Vue + Spring Boot 项目实战（六）：前端路由与登录拦截器 仅仅靠下面的前端拦截实现是不可行的，存在绕过风险，这里暂不讨论。详细请参考博客Vue + Spring Boot 项目实战（十四）：用户认证方案与完善的访问拦截的第二部分：完善的访问拦截。 引入Vuex：123456789101112131415161718import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; user: &#123; username: window.localStorage.getItem(&#x27;user&#x27; || &#x27;[]&#x27;) == null ? &#x27;&#x27; : JSON.parse(window.localStorage.getItem(&#x27;user&#x27; || &#x27;[]&#x27;)).username &#125; &#125;, mutations: &#123; login (state, user) &#123; state.user = user window.localStorage.setItem(&#x27;user&#x27;, JSON.stringify(user)) &#125; &#125;&#125;)配置vue-router，修改router/index.js12345678910111213141516171819202122232425import Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;import AppIndex from &#x27;@/components/home/AppIndex&#x27;import Login from &#x27;@/components/Login&#x27;Vue.use(Router)export default new Router(&#123; mode: &#x27;history&#x27;, routes: [ &#123; path: &#x27;/login&#x27;, name: &#x27;Login&#x27;, component: Login &#125;, &#123; path: &#x27;/index&#x27;, name: &#x27;AppIndex&#x27;, component: AppIndex, meta: &#123; requireAuth: true &#125; &#125; ]&#125;)配置main.js123456789101112131415161718192021222324252627282930313233343536373839import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;import ElementUI from &#x27;element-ui&#x27;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;var axios = require(&#x27;axios&#x27;)axios.defaults.baseURL = &#x27;http://localhost:8443/api&#x27;Vue.prototype.$axios = axiosVue.config.productionTip = falseVue.use(ElementUI)router.beforeEach((to, from, next) =&gt; &#123; if (to.meta.requireAuth) &#123; if (store.state.user.username) &#123; next() &#125; else &#123; next(&#123; path: &#x27;login&#x27;, query: &#123;redirect: to.fullPath&#125; &#125;) &#125; &#125; else &#123; next() &#125; &#125;)/* eslint-disable no-new */new Vue(&#123; el: &#x27;#app&#x27;, render: h =&gt; h(App), router, store, components: &#123; App &#125;, template: &#x27;&lt;App/&gt;&#x27;&#125;)配置Login.vue（已删除UI部分，只保留了js脚本）123456789101112131415161718192021222324252627282930313233export default &#123; name: &#x27;Login&#x27;, data () &#123; return &#123; loginForm: &#123; username: &#x27;admin&#x27;, password: &#x27;123&#x27; &#125;, responseResult: [] &#125; &#125;, methods: &#123; login () &#123; var _this = this console.log(this.$store.state) this.$axios .post(&#x27;/login&#x27;, &#123; username: this.loginForm.username, password: this.loginForm.password &#125;) .then(successResponse =&gt; &#123; if (successResponse.data.code === 200) &#123; // var data = this.loginForm _this.$store.commit(&#x27;login&#x27;, _this.loginForm) var path = this.$route.query.redirect this.$router.replace(&#123;path: path === &#x27;/&#x27; || path === undefined ? &#x27;/index&#x27; : path&#125;) &#125; &#125;) .catch(failResponse =&gt; &#123; &#125;) &#125; &#125;&#125;后端拦截可参考本人另外的博客：后端登录拦截/过滤这两篇博客均是学习Vue + Spring Boot 项目实战（六）：前端路由与登录拦截器的解决心得。","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/categories/Java-Web/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://blog.kcaracal.com/tags/Vue/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/tags/Java-Web/"}]},{"title":"搭建Hexo博客","slug":"服务器搭建Hexo","date":"2020-08-19T16:00:00.000Z","updated":"2021-03-14T09:03:54.838Z","comments":true,"path":"2020/08/19/5efb209b3054/","link":"","permalink":"http://blog.kcaracal.com/2020/08/19/5efb209b3054/","excerpt":"","text":"首先看个服务器搭建Hexo的整体架构图，非常好，有利于理解接下来的步骤。来自博客：如何在服务器上搭建hexo博客 步骤大纲：一、 本地计算机配置Hexo程序二、服务端配置网站根目录、Git裸仓库、Git-hooks、Nginx。三、 本地计算机与服务端建立通道，实现hexo上传。四、本地计算机渲染博客并部署到服务器。 一、本地计算机配置Hexo程序Note: 本地计算机为Deepin系统，理论上适用Ubuntu、Debian 安装及配置git（使用git形式向服务器部署博客时需要安装git） 确保本地计算机中含有git，否则安装git，Ubuntu下安装git命令是 1sudo apt-get install -y git # -y的含义是确定安装git，如果没有-y，系统会提问你是否确认安装git，输入y即可 配置本机git属性 12git config --global user.name &quot;your name&quot; # 引号内填写用户名git config --global user.email &quot;your email&quot; # 引号内填写邮箱 hexo需要node.js的支持，所以需要安装nodejs 打开终端窗口，根据系统输入以下命令之一：其他nodejs版本请参考Node.js Binary Distributionsnpm会随nodejs一起安装成功。 1234567# Using Ubuntucurl -sL https://deb.nodesource.com/setup_lts.x | sudo -E bash -sudo apt-get install -y nodejs# Using Debian, as rootcurl -sL https://deb.nodesource.com/setup_lts.x | bash -apt-get install -y nodejs 验证是否安装成功： 1234# node -v返回 v12.18.3node -v# npm -v返回 6.14.6npm -v 初始化Hexo博客 安装Hexo选择目录存放本地hexo博客内容（假设在主目录/home/$(whoami)/），运行 1npm install -g hexo-cli 初始化hexo：1hexo init blog # blog可以是其他任何你想起的名字 安装hexo其他插件：1234cd blognpm install #这个操作功能是补全依赖环境npm install hexo-deployer-git --save # 自动部署到服务器需要的插件npm install hexo-server # 本地简单的服务器，可以测试hexo是否安装成功 测试hexo是否安装成功。执行如下命令：1hexo g &amp;&amp; hexo server 然后访问localhost:4000，如果能看到hexo界面说明本地hexo安装成功。二、服务端配置网站根目录、Git裸仓库、Git-hooks、Git上传用户、Nginx。 配置网站根目录备用 指定一个目录，本文指定主目录/home/$(whoami)/，创建文件夹hexo 12cd /home/$(whoami) #/home/$(whoami)就是主目录~mkdir hexo 服务端配置Git裸仓库 指定一个目录创建git裸仓库，本文选择目录/var/repo/。执行： 1sudo git init --bare blog.git 配置git-hooks 切换到hooks文件夹1cd /var/repo/blog.git/hooks 创建文件post-receive，执行vim post-receive，进入vim在insert模式下输入以下命令，其中$(whoami)就是用户名。12# !/bin/shgit --work-tree=/home/$(whoami)/hexo --git-dir=/var/repo/blog.git checkout -f 然后:wq保存 （非必需）确保git用户具备运行post-receive的权利，否则执行： 12# 正确形式：-rwxr-xr-x 1 git git 72 Aug 20 14:09 post-receive*chmod 755 post-receive 配置Nginx 安装Nginx： 1sudo apt-get install nginx 配置Nginx.conf：Nginx.conf位置是/etc/nginx/nginx.conf（也可能是/user/local/nginx/conf，可以whereis nginx命令查看具体位置）。编辑该文件内容，修改user、server12345678910111213user root;....http &#123; server &#123; listen 80; # 监听端口 server_name &quot;your url or ip&quot;; # 域名或者ip地址 location / &#123; root /home/xxx/hexo; # 服务端网站根目录，xxx是用户名，等于$(whoami) index index.html; &#125; &#125;&#125; 然后保存。三、本地计算机与服务端建立通道，实现hexo上传。 服务端创建并配置git用户，专门用于博客上传。 创建git用户，并更改git仓库的所有者 12sudo adduser git # 创建用户sudo chown -R git:git /var/repo/blog.git # 指定blog.git的所有者为git 禁用 git 用户的 shell 登录权限 出于安全考虑，我们要让 git 用户不能通过 shell 登录。可以编辑 /etc/passwd来实现 将git:x:1001:1001:,,,:/home/git:/bin/bash改成git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样 git 用户可以通过 ssh 正常使用 git，但是无法登录 shell。可以在服务端试一下，su git无法切换到git用户，报错fatal: Interactive git shell is not enabled. 新建git用户的原因出在这里，要使用一个不可以ssh远程登录的用户，而服务器主用户不能完成这样的需求。 本地计算机与服务端建立ssh通道。 本地计算机在/home/$(whoami)/.ssh执行如下命令（若/home/$(whoami)下没有.ssh目录，则创建.ssh目录）。1ssh-keygen 一直回车即可。这一步操作会在/home/$(whoami)/.ssh/下生成两个文件id_rsa和id_rsa.pub。 服务端在/home/git目录下创建文件夹.ssh，并在/home/git/.ssh下创建文件authorized_keys。把id_rsa.pub的内容复制到服务端的authorized_keys中。注意是把本地计算机的/home/$(whoami)/.ssh/id_rsa.pub复制到服务端的/home/git/.ssh/authorized_keys。 本地计算机配置hexo deploy。 编辑/home/xxx/blog/_config.yml，配置deploy： 1234deploy: type: git repo: git@&quot;your domain or ip&quot;:/var/repo/blog.git branch: master 保存。 假如服务器端ssh服务的端口非默认端口22号，则本地计算机_config.yml按如下配置 1234deploy: type: git repo: ssh://git@&quot;your domain or ip&quot;:&quot;ssh port&quot;/var/repo/blog.git branch: master hexo之处多向部署，即部署到多个服务器，比如同时部署到服务器和github pages 1234567deploy:- type: git repo: git@&quot;your domain or ip&quot;:/var/repo/blog.git branch: master- type: git repo: git@github.com:&quot;name&quot;/&quot;name&quot;.github.io.git branch: master 四、本地计算机渲染博客并部署到服务器。 编写博客 方式一：创建博客使用的markdown文件，然后书写内容 1hexo new &quot;xxxx&quot; 创建成功后，该markdown文件在source/_posts目录下。继续编辑xxx.md即可。 方式二：直接把写好了的md文件丢进source/_posts目录下。 渲染博客： 1hexo gernerate 或者 1hexo g 部署博客到服务器 1hexo deploy 或者 1hexo d 第二步和第三步可以一起使用 1hexo g &amp;&amp; hexo d 或者 1hexo g -d 或者 1hexo d -g 操作完成后，服务端目录/home/deepin/hexo下会有刚刚提交的博客，但/var/repo/blog.git/branches不会有博客文件，因为它是裸仓库。注意：hexo d可能会报错Error: EACCES: permission denied, unlink ...，说什么权限拒绝。如果使用sudo hexo d，就会报另外一种错误：git@github.com: Permission denied (publickey). fatal: 无法读取远程仓库。。解决办法：一劳永逸，直接chmod -R 777 blog/。参考博客：使用Hexo+Github搭建博客的各种问题 完工。整个流程请照文章开头的架构图理解一下，比较难理解的是第二章节和第三章节。 其他发现：hexo支持Git以外的其他部署方式，详见官网文档：一键部署。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog.kcaracal.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.kcaracal.com/tags/hexo/"}]},{"title":"多线程基础——CAS","slug":"CAS基础","date":"1970-01-01T00:00:00.000Z","updated":"2020-11-24T02:58:28.000Z","comments":true,"path":"1970/01/01/f516cd5057f5/","link":"","permalink":"http://blog.kcaracal.com/1970/01/01/f516cd5057f5/","excerpt":"","text":"CAS概念：CAS全称Compare And Swap，中文是对比并交换，是乐观锁的一种，是说多线程之一在写入修改值前先判定内存位置V中的值是否是预期值，是则修改V中的值，否则获取V中的值重复CAS。 CAS的过程是：(1) 线程读取内存位置V中当前值E到线程内部，然后修改E，写回内存前再次获取位置V的值，假如是N，判断N\\==E?，如果N\\==E，说明没有其他线程修改位置V的值，执行写回操作。CAS流程图如下（来自马士兵老师公开课程） ABA问题ABA是：如果线程1第二次获取位置V处的值依旧是E，但是这个E应不是一开始的E了，它可能被线程2变换了两次，举个例子就是E-&gt; X -&gt; E，但是线程1并不知道，然后修改了内存V的值，这个过程就发生了ABA问题。ABA问题的解决方式可以利用版本号或者时间戳。相关类有 AtomicStampedReference. CAS原理CAS是使用JDK类UnSafe实现的，UnSafe类是使用C++代码实现的，往更底层来讲，是通过汇编代码实现的。 Unsafe类中对应的代码是： 12345678inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) &#123; int mp == os::is_MP(); __asm__ volatile (LOCK_IF_MP(%4)) &quot;cmpxchgl %1,(%3)&quot; : &quot;=a&quot; (exchange_value) : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp) : &quot;cc&quot;, &quot;memory&quot;); return exchange_value;&#125; 关键在于：(LOCK_IF_MP(%4)) “cmpxchgl %1,(%3)”。 这说明CAS的底层实现还是依靠汇编指令cmpxchg LOCK_IF_MP是说：如果多线程(MP=Multi Processor)，则需要在汇编命令cmpxchg前加上lock 因此，关键指令就是lock cmpxchg lock指令可以保证线程执行CAS的过程不受干扰，即加上锁，避免线程写回内存过程位置V处的值发生改变。 lock的硬件原理是：lock指令在执行后面指令的时候锁定一个北桥信号，网上也说是锁内存总线或者cache，这部分去网上翻了翻，大致找到了以下几个资料： 计算机总线结构详解 lock指令 x86系统cache locking的原理 感谢马老师。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kcaracal.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kcaracal.com/tags/Java/"}]},{"title":"Intellij-IDEA利用spring-initializr添加maven依赖包","slug":"Intellij-IDEA利用spring-initializr添加maven依赖包","date":"1970-01-01T00:00:00.000Z","updated":"2021-03-13T12:15:19.786Z","comments":true,"path":"1970/01/01/f3baf0d72b9f/","link":"","permalink":"http://blog.kcaracal.com/1970/01/01/f3baf0d72b9f/","excerpt":"","text":"利用spring-initializr创建spring-boot项目时，可以直接选择依赖，创建成功后，这些依赖就会自动存在pom.xml中。但在项目编写过程中如果还想利用spring-initializer引入部分依赖，怎么办？ 这就需要一个IDEA插件，叫EditStarters，可以直接利用spring-initiizer像创建项目时添加依赖包，很方便。 具体参考链接：IntelliJ IDEA中如何再次调出springboot的依赖窗口，随时可以根据喜好导入和移除插件 贴一个添加成功的依赖和插件主页面主页面：","categories":[{"name":"Misc","slug":"Misc","permalink":"http://blog.kcaracal.com/categories/Misc/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://blog.kcaracal.com/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://blog.kcaracal.com/tags/Java/"}]},{"title":"LeetCode-146--LRU缓存机制","slug":"LeetCode-146--LRU缓存机制","date":"1970-01-01T00:00:00.000Z","updated":"2020-09-22T12:32:23.000Z","comments":true,"path":"1970/01/01/bec7b2741480/","link":"","permalink":"http://blog.kcaracal.com/1970/01/01/bec7b2741480/","excerpt":"","text":"题目描述:运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。请在 O(1) 时间复杂度内完成这两种操作。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lru-cache著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解答：方法一：（来自LeetCode官方题解）使用自带的LinkedHashMap，可以直接模拟LRU。LinkedHashMap的数据结构是在HashMap的基础上，为每个HashMap节点都增加了两个属性before、after，并用双链表把每个节点连接起来，before、after分别代表某元素在双链表的前一个、后一个元素。详细可参考Java集合详解5：深入理解LinkedHashMap和LRU缓存 1234567891011121314151617181920212223242526272829303132333435//LinkedHashMap的双向链表实现LRU，最后节点为常访问的，头部的节点是最近最久未使用的import java.util.LinkedHashMap;class LRUCache extends LinkedHashMap &#123; int capacity; LRUCache(int capacity) &#123; // 需要使用LinkedHashMap中accessOrder=true的构造函数 // LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder) // 顺便说个知识点，HashMap初始化并不会分配内存，分配是在第一次put元素后 super(capacity, 0.75F, true); this.capacity = capacity; &#125; public int get(int key) &#123; // 这个函数是getkey，如果取不到，则返回defaulValue，即第二个参数 return super.getOrDefault(key, -1); &#125; public void put(int key, int value) &#123; // 直接继承HashMap的put方法，如果accessOrder=true，则会把刚访问的节点或者新添加的节点安排到双链表末尾 super.put(key, value); &#125; @Override protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) &#123; // LinkedHashMap继承HashMap，二者的removeEldestEntry均return false，表示不删除最近最久未使用节点 // 需要重写，这里的逻辑是当元素个数大于初始容量时 // // HashMap的threshold修饰级别是default，除了HashMap的实例外，HashMap所在package的其他类也可以访问， // 但是除此之外其他都不能访问。因此，这里发生删除元素时，size&gt;16，实际的capacity&gt;24(16/0.75=24) return size() &gt; capacity; &#125;&#125; 方法二：哈希表+双向链表方式构造LRU。HashMap用来定位某元素在节点中的位置，映射关系是，(HashMap).get(key)直接拿到节点。双向链表模拟LRU缓存，头部位置代表最近访问过的，尾部表示最久未使用的。原因：访问过的都往头部转移，那些不常访问的元素就会越来越往后移动。 这个哪一端是刚刚访问的，随你心情定义，你也可以定义尾部就是刚刚访问的，而头部是最久未使用的。get(int key)的逻辑：寻找某元素时，找不到就返回-1，找得到就返回value，并把该元素移动到头部，代表最近访问了，久而久之，尾部就会使最久未使用的元素。put(int key, int value)的逻辑是，如果不是新元素，就更新该元素value（同时意味着该元素要移动到开头,可以利用get(key)判断是否是新元素，若元素已存在就会移动到开头，然后更新开头元素value）；如果是新元素，容量足够就加到头部，代表刚刚访问；容量不够，就得移除尾部节点，再在头部节点添加元素。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Stack;class ListNode &#123; int key; int value; ListNode before; ListNode after; ListNode(int key, int value) &#123; this.key = key; this.value = value; &#125;&#125;class LRUCache &#123; int capacity; // head和tail操作来自LinkedHashMap思想，好处是可以避免好多节点判空操作，比较方便。 // 牺牲两个节点空间换来操作方便，可以作为编程技巧。 ListNode head; ListNode tail; Map&lt;Integer, ListNode&gt; map; LRUCache(int capacity) &#123; this.capacity = capacity; head = new ListNode(-1, -1); tail = new ListNode(-1, -1); head.after = tail; tail.before = head; map = new HashMap&lt;&gt;(); &#125; // get的逻辑是：找不到返回-1，找得到就返回value，并把该元素移动到头部，代表最近访问了，久而久之，尾部就会使最久未使用的元素 public synchronized int get(int key) &#123; if (capacity == 0) return -1; ListNode vn = map.get(key); // 找不到元素 if (vn == null) return -1; // 找到元素，无论它在哪，肯定有前后节点，最不济是head和tail，所以前后节点一定不为空 // 如果vn是头一个节点，不必操作，直接返回 if (vn.before == head) return vn.value; // 否则，在vn原来的地方移除vn removeNode(vn); // 移动到开头 addToHead(vn); return vn.value; &#125; // put的逻辑是，如果不是新元素，就更新该元素value(同时意味着该元素要移动到开头,可以利用get判断是否是新元素，若元素已存在会移动到开头)； // 如果是新元素，容量够就加到头部，代表刚刚访问；容量不够，就得移除尾部节点，再在头部节点添加元素 public synchronized void put(int key, int value) &#123; if (capacity == 0) return; // 增添就意味着可能要移除元素 int v = get(key); // 并非新元素，更新 if (v != -1) &#123; head.after.value = value; return; &#125; ListNode newNode = new ListNode(key, value); /* 这个注释掉的内容是添加新节点的另一个方式 // 超容量就删除尾部节点 if (map.size() + 1 &gt; capacity) &#123; map.remove(tail.before.key); removeNode(tail.before); &#125; // 添加节点到头部 map.put(key, newNode); addToHead(newNode); */ // 多一个元素不超容量，可以直接压入头部 if (map.size() + 1 &lt;= capacity) &#123; addToHead(newNode); map.put(key, newNode); return; &#125; // 超容量，要去除最后一个最久未使用,并在最前面加入新元素 // tail.before=head是为了防止容量为0，当然可以直接在开头预防 // if (tail.before = head) // return; // 对应map要删除重添加 map.remove(tail.before.key); map.put(key, newNode); removeNode(tail.before); addToHead(newNode); &#125; private synchronized void removeNode(ListNode node) &#123; node.before.after = node.after; node.after.before = node.before; &#125; private synchronized void addToHead(ListNode vn) &#123; ListNode first = head.after; head.after = vn; vn.before = head; vn.after = first; first.before = vn; &#125;&#125;完毕。LRU缓存这道题常见于字节跳动的面试题，这里同时分享一个字节跳动面试常考算法题，来自LeetCode.LeetCode探索之字节跳动","categories":[{"name":"Code","slug":"Code","permalink":"http://blog.kcaracal.com/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://blog.kcaracal.com/tags/Code/"}]},{"title":"Linux-VSCode-Code-Runner编译不生成临时文件(Java)","slug":"Linux-VSCode-Code-Runner编译不生成临时文件(Java)","date":"1970-01-01T00:00:00.000Z","updated":"2021-03-13T12:14:02.471Z","comments":true,"path":"1970/01/01/089dc59aab03/","link":"","permalink":"http://blog.kcaracal.com/1970/01/01/089dc59aab03/","excerpt":"","text":"VSCode Code Runner插件编译Java文件，默认会在源码所在文件生成*.class临时文件，而造成源码文件夹内容混乱，希望自定义位置保存类文件。 解决措施： Setting -&gt; 搜索Code Runner -&gt; 点击左侧”Run Code configuration” -&gt; 右侧找到code-runner.executorMap，点击Edit in settings.json 修改code-runner.executorMap配置，如下：123&quot;code-runner.executorMap&quot;: &#123; &quot;java&quot;:&quot;cd $dir &amp;&amp; javac $fileName &amp;&amp; java $fileNameWithoutExt &amp;&amp; mv $dir/*.class /tmp/vscodesws_*/jdt_ws/jdt.ls-java-project/bin&quot;&#125;, 参数解释：$dir是Java源码文件所在路径；$fileName是文件名，如test2.java；$fileNameWithoutExt是没有后缀的文件名，即test2（Java一般是主类和文件名相同）；最后/tmp/..是自定义的class文件保存路径。 保存再运行，即可在指定路径生成*.class文件，不再一股脑保存在源码文件。 其他编程语言，可以bing搜索”coderunner 不生成临时文件”查看其他教程。或者参考https://github.com/formulahendry/vscode-code-runner/issues/338","categories":[{"name":"Misc","slug":"Misc","permalink":"http://blog.kcaracal.com/categories/Misc/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kcaracal.com/tags/Linux/"}]},{"title":"Mybatis-Mybatis-Plus忽略实体类某字段","slug":"Mybatis-Mybatis-Plus忽略实体类某字段","date":"1970-01-01T00:00:00.000Z","updated":"2020-09-30T09:19:17.000Z","comments":true,"path":"1970/01/01/0ded09ceef67/","link":"","permalink":"http://blog.kcaracal.com/1970/01/01/0ded09ceef67/","excerpt":"","text":"情况： 1. 数据库表有字段id、cola、colb，映射到Java实体类会有属性id，colA，colB。现在我们需要再在实体类中新添加一个自定义属性colC。 2. 但是，colC并非数据库字段，如果不做处理，mybatis执行sql过程中会报错，`Cause: java.sql.SQLSyntaxErrorException: Unknown column &#39;children&#39; in &#39;field list&#39;` 解决：对colC属性使用注解@TableField(exist = false)参考博客：MyBatisPlus 如何忽略数据库和实体类之间的映射字段MyBatis实体非字段的属性注解（ps：该博客另外提到：hibernate实现该目的是使用注解@Transient ）","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/categories/Java-Web/"}],"tags":[{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/tags/Java-Web/"},{"name":"Mybatis-Plus","slug":"Mybatis-Plus","permalink":"http://blog.kcaracal.com/tags/Mybatis-Plus/"}]},{"title":"Vue嵌套路由","slug":"Vue嵌套路由","date":"1970-01-01T00:00:00.000Z","updated":"2020-09-04T15:34:25.000Z","comments":true,"path":"1970/01/01/ae0aa5f31aa4/","link":"","permalink":"http://blog.kcaracal.com/1970/01/01/ae0aa5f31aa4/","excerpt":"","text":"使用Vue嵌套路由的情况多半是要在某组件中嵌套其他组件渲染，比如要在主页添加其他内容。简单说说步骤，详情：Vue 嵌套路由，以及其他两篇参考：Vue-Router路由嵌套理解、Vue嵌套路由（vue-cli项目写法）组件嵌套举例：1234567+------------------+| Home || +--------------+ | | | index | || | | || +--------------+ |+------------------+ 父组件中要配置 &lt;router-view /&gt;12345&lt;template&gt; &lt;div&gt; &lt;router-view /&gt; &lt;/div&gt;&lt;/template&gt; 要配置路由嵌套1234567891011121314151617181920212223242526routes: [ &#123; path: &#x27;/home&#x27;, name: &#x27;Home&#x27;, component: Home, children: [ &#123; /* 注意path的写法, 要注意, 以 / 开头的嵌套路径会被当作根路径。这让你充分的使用嵌套组件而无须设置嵌套的路径。 &#x27;index&#x27; -&gt; 访问路径 = /home/index &#x27;/index&#x27; -&gt; 访问路径 = /index &#x27;/home/index&#x27; -&gt; 访问路径 = /home/index */ path: &#x27;/index&#x27;, name: &#x27;AppIndex&#x27;, component: AppIndex, meta: &#123; requireAuth: true &#125; &#125;, &#123; path: &#x27;/other&#x27;, name: &#x27;Other&#x27;, component: OtherIndex, &#125; ] &#125;, 注意&lt;router-view /&gt;不能遗漏，以及父子路由的写法。","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/categories/Java-Web/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://blog.kcaracal.com/tags/Vue/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/tags/Java-Web/"}]},{"title":"Deepin删除打开方式的多余项","slug":"deepin删除打开方式的多余项","date":"1970-01-01T00:00:00.000Z","updated":"2020-09-04T16:05:22.000Z","comments":true,"path":"1970/01/01/5b276bc843ec/","link":"","permalink":"http://blog.kcaracal.com/1970/01/01/5b276bc843ec/","excerpt":"","text":"情况复现： deepin打开txt文件时，打开方式支持选择默认程序，如下图，可以选择系统提供好的应用，如文件编辑器，亦可以添加其他程序。 假设我们没有找对路径，错误选择了一个应用，导致如下界面（图中的sublime_text是错误的）： 我们想删除第二个sublime_text，怎么办？ 解决办法： 上面的操作会在开始菜单中多出一个sublime_text 这个sublime_text的位置一般是：~/.local/share/applications下，找到删除即可。 再次右键查看打开方式，发现已经删除。","categories":[{"name":"Deepin","slug":"Deepin","permalink":"http://blog.kcaracal.com/categories/Deepin/"}],"tags":[{"name":"Deepin","slug":"Deepin","permalink":"http://blog.kcaracal.com/tags/Deepin/"}]},{"title":"Deepin安装Mininet","slug":"deepin安装mininet","date":"1970-01-01T00:00:00.000Z","updated":"2020-09-30T09:15:31.000Z","comments":true,"path":"1970/01/01/187724774666/","link":"","permalink":"http://blog.kcaracal.com/1970/01/01/187724774666/","excerpt":"","text":"Mininet本身不支持Deepin系统，仅仅支持Ubuntu、Debian、Fedora、RedHatEnterpriseServer、SUSE LINUX。这类系统的教程参考：Mininet使用源码安装 首先确认系统是否有git，有就跳过”安装git“这一步，否则执行下面所有操作。(deepin v20下好像没有git) 安装git：sudo apt install git 安装完git后，运行命令ssh-keygen，一路回车就好。 登录GitHub，添加/home/xxx/.ssh/id_rsa.pub的内容到github的ssh keys中，这一步可以参考博客：GitHub 添加 SSH keys。这一步是为了执行下面的git clone git://….时不会报错。 获取Mininet源码：git clone git://github.com/mininet/mininet 选择Mininet安装版本： 123cd minintgit tag # 所有版本git checkout -b 2.3.0d4 # 版本需要根据git tag结果自己选择 执行安装： 修改install.sh脚本，保证deepin环境可以安装！ Mininet确定系统是否支持的逻辑就写在这个脚本中，修改代码如下（就是在DIST中添加了Deepin）： 12345DISTS=&#x27;Deepin|Ubuntu|Debian|Fedora|RedHatEnterpriseServer|SUSE LINUX&#x27;if ! echo $DIST | egrep &quot;$DISTS&quot; &gt;/dev/null; then echo &quot;Install.sh currently only supports $DISTS.&quot; exit 1fi 只修改这是不行的，我们需要确定DIST从哪来，往上翻，发现这样一片代码： 12345678910111213test -e /etc/debian_version &amp;&amp; DIST=&quot;Debian&quot;grep Ubuntu /etc/lsb-release &amp;&gt; /dev/null &amp;&amp; DIST=&quot;Ubuntu&quot;if [ &quot;$DIST&quot; = &quot;Ubuntu&quot; ] || [ &quot;$DIST&quot; = &quot;Debian&quot; ]; then # Truly non-interactive apt-get installation install=&#x27;sudo DEBIAN_FRONTEND=noninteractive apt-get -y -q install&#x27; remove=&#x27;sudo DEBIAN_FRONTEND=noninteractive apt-get -y -q remove&#x27; pkginst=&#x27;sudo dpkg -i&#x27; update=&#x27;sudo apt-get&#x27; # Prereqs for this script if ! which lsb_release &amp;&gt; /dev/null; then $install lsb-release fifi 把这里的代码复制一份，然后修改DIST为Deepin即可，贴一个我改的： 1234567891011121314test -e /etc/debian_version &amp;&amp; DIST=&quot;Deepin&quot;grep Deepin /etc/lsb-release &amp;&gt; /dev/null &amp;&amp; DIST=&quot;Deepin&quot;if [ &quot;$DIST&quot; = &quot;Deepin&quot; ] || [ &quot;$DIST&quot; = &quot;Debian&quot; ]; then # Truly non-interactive apt-get installation install=&#x27;sudo DEBIAN_FRONTEND=noninteractive apt-get -y -q install&#x27; remove=&#x27;sudo DEBIAN_FRONTEND=noninteractive apt-get -y -q remove&#x27; pkginst=&#x27;sudo dpkg -i&#x27; update=&#x27;sudo apt-get&#x27; # Prereqs for this script if ! which lsb_release &amp;&gt; /dev/null; then $install lsb-release fifi 执行安装 mininet/util/install.sh -a 最后的参数-a参数可以自己选择，也可以-nvf只安装mininet、OpenFlow、Open vSwitch。具体参数可以参考官网或者Mininet使用源码安装 确认安装成功 执行sudo mn，能够建立最简单的网络拓扑，执行pingall可以全网ping通 为什么Mininet可以在deepin环境下安装成功： 因为Ubuntu和Deepin都是基于Debian构建，没道理Mininet支持Ubuntu，而不支持Deepin，毕竟二者师出同门。","categories":[{"name":"Deepin","slug":"Deepin","permalink":"http://blog.kcaracal.com/categories/Deepin/"}],"tags":[{"name":"Deepin","slug":"Deepin","permalink":"http://blog.kcaracal.com/tags/Deepin/"},{"name":"Mininet","slug":"Mininet","permalink":"http://blog.kcaracal.com/tags/Mininet/"}]},{"title":"deepin编辑开始菜单项","slug":"deepin编辑菜单项","date":"1970-01-01T00:00:00.000Z","updated":"2020-09-04T16:05:22.000Z","comments":true,"path":"1970/01/01/bde005788ae8/","link":"","permalink":"http://blog.kcaracal.com/1970/01/01/bde005788ae8/","excerpt":"","text":"需要的实例图： 情况一：删除开始菜单项 实例：删除菜单项Intellij IDEA和sublime_text 方法： 确定菜单位置 位置1：/usr/share/applications/com.jetbrains.intellij-idea-ultimate.desktop 位置2：~/.local/share/applications/sublime_text 执行删除，注意在/usr/share/applications下删除文件需要权限。 情况二：修改开始菜单项图标、指向的应用 实例：修改Intellij IDEA运行目录、图标 方法： 确定菜单位置：/usr/share/applications/com.jetbrains.intellij-idea-ultimate.desktop 编辑该desktop文件（需要管理员权限）： 12345678910111213[Desktop Entry]Version=1.0Type=ApplicationName=IntelliJ IDEA Ultimate EditionIcon=intellij-idea-ultimateExec=&quot;/opt/apps/com.jetbrains.intellij-idea-ultimate/files/share/intellij-idea-ultimate/bin/idea.sh&quot; %fComment=Capable and Ergonomic IDE for JVMCategories=Development;IDE;Terminal=falseStartupWMClass=jetbrains-ideaX-Deepin-CreatedBy=com.deepin.dde.daemon.LauncherX-Deepin-AppID=com.jetbrains.intellij-idea-ultimate 这里的Icon代表图标，Exec代表运行命令，按照自己意愿更改即可。","categories":[{"name":"Deepin","slug":"Deepin","permalink":"http://blog.kcaracal.com/categories/Deepin/"}],"tags":[{"name":"Deepin","slug":"Deepin","permalink":"http://blog.kcaracal.com/tags/Deepin/"}]},{"title":"shell编程：判断数组是否包含某个元素","slug":"shell编程：判断数组是否包含某个元素","date":"1970-01-01T00:00:00.000Z","updated":"2021-03-13T15:43:15.628Z","comments":true,"path":"1970/01/01/77f1a42b13ac/","link":"","permalink":"http://blog.kcaracal.com/1970/01/01/77f1a42b13ac/","excerpt":"","text":"简单描述： 如数组$arr=(1\\ 2\\ 3\\ 4), target_1=4, target_2=5$。期望编写函数$IsContains()$，分别接受两个参数$arr$和$targe_i$，返回——0(True)或1(False)12345678910111213IsContains()&#123; # 把原来的arr新赋值给一个新数组 narr=($1) # 逻辑是判断删除\\$2后的数组是否与原数组相同，不同则标明包含元素，相同（没有\\$2可删除）则标明不包含元素 [[ $&#123;narr[@]/$2/&#125; != $&#123;narr[@]&#125; ]];echo $?&#125;arr=(1 2 3 4)target1=4target2=5# $&#123;arr[*]&#125;!, not $&#123;arr[@]&#125;! TestResult: $&#123;arr[@]&#125;=&gt; narr=(1), $&#123;arr[*]=&gt; narr=(1 2 3 4)# but i don&#x27;t know whyecho `IsContains &quot;$&#123;arr[*]&#125;&quot; $target1`echo `IsContains &quot;$&#123;arr[*]&#125;&quot; $target2`代码中有个疑问，当调用的主参使用$arr[@]时，IsContains函数中$1=(1)，当调用的主参使用$arr[*]时，IsContains函数中$1=(1 2 3 4)。不知道为什么，可能我对shell编程还是一知半解吧。望能看到这篇博客的大佬给予解答，谢谢。 另外关于shell判断逻辑——if [[]]、(())、[] 的区别，可以参考博客:[shell if [[ ]]和 ]区别 || &amp;&amp;该文章有参考博客：Bash数组-判断某个元素是否在数组内的几种方法 Shell数组与字符串：shell脚本编程进阶之数组、字符串切片","categories":[{"name":"Shell","slug":"Shell","permalink":"http://blog.kcaracal.com/categories/Shell/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kcaracal.com/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://blog.kcaracal.com/tags/Shell/"}]},{"title":"后端登录拦截/过滤","slug":"后端登录拦截-过滤","date":"1970-01-01T00:00:00.000Z","updated":"2020-11-11T14:51:34.000Z","comments":true,"path":"1970/01/01/0c1335e44775/","link":"","permalink":"http://blog.kcaracal.com/1970/01/01/0c1335e44775/","excerpt":"","text":"记录项目学习过程中的一个知识点——后端登录拦截。并思考用一种方式——Servlet Filter实现该功能。 注：拦截器@Override的prehandle逻辑，在后期学习过程修改为了shiro验证，本文代码不再修改，详情见Vue + Spring Boot 项目实战（十四）：用户认证方案与完善的访问拦截 项目还是那个项目：Vue + Spring Boot 项目实战（一）：项目简介还是第6节Vue + Spring Boot 项目实战（六）：前端路由与登录拦截器。 文中有讲到一个需求——后端登录拦截，意思就是没有登录的用户，必须要求其登录之后才可以访localhost:8843/blog/index页面。文中实现的方式使用拦截器，拦截器是什么?拦截器是SpringMVC的一种机制，类似于Servlet的过滤器Filter，主要实现对某个处理方法进行拦截，执行某些操作。有个链接可参考： Spring MVC拦截器（Interceptor ）详解 如何使用拦截器实现登录拦截? （原文：Vue + Spring Boot 项目实战（六）：前端路由与登录拦截器的实现方式） 首先自定义一个类实现HandlerInterceptor，比如public class LoginInterceptor implements HandlerInterceptor，然后重写回调函数preHandle。这里的逻辑就是：判断request.getServletPath()是否是否是&quot;/index&quot;，如果是，就判断是否登录（session.getAttribute(&quot;user&quot;) 是否为空），没有登录就重定向到&quot;/login&quot;（response.sendRedirect(request.getContextPath() + &quot;/login&quot;); 然后自定义类实现WebMvcConfigurer ，重写addInterceptors，把上面的LoginInterceptor注册到拦截器中。贴一个我自己写的代码，可以对比着原文代码看看(注意不要忘了注解)：123456789101112131415public class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; HttpSession session = request.getSession(); String servletPath = request.getServletPath(); if (servletPath.startsWith(&quot;/index&quot;)) &#123; if (session.getAttribute(&quot;user&quot;) == null) &#123; System.out.println(&quot;Not Login&quot;); response.sendRedirect(request.getContextPath() + &quot;/login&quot;); return false; &#125; &#125; return true; &#125;&#125; 12345678910111213@SpringBootConfigurationpublic class MyWebConfigurer implements WebMvcConfigurer &#123; @Bean public LoginInterceptor getLoginInterceptor() &#123; return new LoginInterceptor(); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(getLoginInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/index.html&quot;); &#125;&#125; 下面是原博客中的LoginInterceptor的实现：123456789101112131415161718192021222324252627282930313233343536public class LoginInterceptor implements HandlerInterceptor&#123; @Override public boolean preHandle (HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; HttpSession session = httpServletRequest.getSession(); String contextPath=session.getServletContext().getContextPath(); String[] requireAuthPages = new String[]&#123; &quot;index&quot;, &#125;; String uri = httpServletRequest.getRequestURI(); uri = StringUtils.remove(uri, contextPath+&quot;/&quot;); String page = uri; if(begingWith(page, requireAuthPages))&#123; User user = (User) session.getAttribute(&quot;user&quot;); if(user==null) &#123; httpServletResponse.sendRedirect(&quot;login&quot;); return false; &#125; &#125; return true; &#125; private boolean begingWith(String page, String[] requiredAuthPages) &#123; boolean result = false; for (String requiredAuthPage : requiredAuthPages) &#123; if(StringUtils.startsWith(page, requiredAuthPage)) &#123; result = true; break; &#125; &#125; return result; &#125;&#125; 既然一些博客在介绍SpringMVC的拦截器时说类似Servlet的Filter，那能否用Filter实现呢？我做了做实验，应该是可以的。但因为博主还是小白，因此如果写的不对，还请读者指教。逻辑和拦截器的代码差不多，就是对所有url先拦截，在判断ServletPath的前缀是不是&quot;/index&quot;，是的话就判断用户是否登录，没有登录就重定向到&quot;/login&quot;，已经登录就放行。直接上代码吧，同样注意不要忘了注解。1234567891011121314151617181920212223242526272829303132333435@Configuration@WebFilter(filterName = &quot;LoginFilter&quot;, urlPatterns = &#123;&quot;/*&quot;&#125;)@Order(value = 1)public class LoginFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; HttpSession session = request.getSession(); System.out.println(&quot;Servlet Path=&quot; + request.getServletPath()); if (request.getServletPath().startsWith(&quot;/index&quot;)) &#123; User user = (User) session.getAttribute(&quot;user&quot;); if (user == null) &#123; System.out.println(&quot;Not Login&quot;); response.sendRedirect(request.getContextPath() + &quot;/login&quot;); &#125; else &#123; //放行 filterChain.doFilter(request, response); &#125; &#125; else &#123; filterChain.doFilter(request, response); &#125; &#125; @Override public void destroy() &#123; &#125;&#125; 请仔细理解这两种方式的代码。如果您感觉我写的不对，请批评指正。我能写出来也是“麦芒掉进针眼里——凑巧了”。如果您也在学习Vue + Spring Boot 项目实战（六）：前端路由与登录拦截器，并且您实践了我说的这两种方式（前提我写对了，嘿嘿），请您继续往下看。我说一个小细节吧。使用过滤器Filter可以对&quot;/index&quot;和&quot;/index.html&quot;都进行过滤，要求登录以后才能访问，但是使用拦截器的方式并不能对&quot;/index.html&quot;进行拦截，即不要求登录就能访问（注：这个index.html是Vue.js单页面开发，直接访问是空白页面，由于不懂前端，我并不知道是否存在危害，或许可以直接访问并不存在危害，只是我感觉不太好）。因为MyWebConfigurer·中的·addInterceptor()方法有一句excludePathPatterns(&quot;/index.html&quot;)。可是为什么要加这一句呢？原博客也有说明原因，是因为未登录状态下，&quot;/index&quot;会重定向到&quot;/login&quot;界面，然后又因为&quot;/login&quot;使用了ErrorConfig（这个请看原博客，属于项目内容），将HTTP 404重定向到了&quot;/index.html&quot;，&quot;/index.html&quot;的前缀同样是&quot;/index&quot;，未登录情况下再次重定向到&quot;/login&quot;，然后这就造成了死循环，即重定向过多导致页面访问失败了。那为什么Filter不会重定向过多呢？我认为和拦截器、过滤器的机制不同有关，拦截器是属于SpringMVC规范，但过滤器是属于Servlet规范。博客（蛮不错的）《spring boot 过滤器、拦截器的区别与使用》给了几个图，并指出“过滤器和拦截器触发时机不一样，过滤器是在请求进入容器后，但请求进入servlet之前进行预处理的。请求结束返回也是，是在servlet处理完后，返回给前端之前。”这说明，过滤器Filter是在进入容器之后就起作用了，但是拦截器Interceptor是在进入了LoginController之前才被调用，并且这个过程应该是在ErrorConfig的后面（我感觉ErrorConfig的重定向应该是属于dispatcher）。这还有个利用System.out.println()输出Spring组件加载顺序的图，因此，如果MyWebConfigurer中的addIntercepto不写excludePathPatterns(&quot;/index.html&quot;)，就会造成这样的重定向死循环顺序：&quot;/index&quot;(未登录) --&gt; &quot;/login&quot; --&gt; &quot;/index.html&quot; --&gt; &quot;/login&quot; --&gt; &quot;/index.html&quot; --&gt; ...，要把&quot;/index.html&quot;排除在外。截了个图可以看一下：当然，加了excludePathPatterns(&quot;/index.html&quot;)，也就如前面所说，意味着&quot;/index.html&quot;不需要登录了，可以直接访问。 好了，说完了。欢迎批评指正。","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/categories/Java-Web/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://blog.kcaracal.com/tags/Spring-Boot/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/tags/Java-Web/"}]},{"title":"小记——cookie，session，token，跨域","slug":"小记cookie，session，token，跨域","date":"1970-01-01T00:00:00.000Z","updated":"2020-11-11T15:04:56.000Z","comments":true,"path":"1970/01/01/a6746dd2dd00/","link":"","permalink":"http://blog.kcaracal.com/1970/01/01/a6746dd2dd00/","excerpt":"","text":"转自：彻底理解cookie，session，token - 墨颜丶 - 博客园token保存在客户端，服务端通过验证数字签名的方式保证用户合法性。 Web项目中的跨域设置：参考博客：CORS 跨域 Cookie 的设置与获取基于Filter实现CORS、Spring注解@CrossOrigin。另外可以也使用拦截器实现CORS。 有关跨域Option请求： 跨域请求过程中，出现一个请求发送两次的现象，第一次是以OPTION方法发送的，第二次才是真正的请求。正式跨域的请求前，浏览器会根据需要，发起一个“PreFlight”（也就是Option请求），用来让服务端返回允许的方法（如get、post），被跨域访问的Origin（来源，或者域），还有是否需要Credentials(认证信息）参考 跨域中option请求详解 preflighted request 在发送真正的请求前, 会先发送一个方法为OPTIONS的预请求(preflight request), 用于试探服务端是否能接受真正的请求，如果options获得的回应是拒绝性质的，比如404\\403\\500等http状态，就会停止post、put等请求的发出。 参考HTTP跨域请求OPTION解析 axios 都是复杂请求，ajax 可以是简单请求。参考简单请求和复杂请求的区别","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/categories/Java-Web/"}],"tags":[{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/tags/Java-Web/"}]},{"title":"利用SQL函数批量插入测试数据","slug":"利用SQL函数批量插入测试数据","date":"1970-01-01T00:00:00.000Z","updated":"2020-11-11T14:52:44.000Z","comments":true,"path":"1970/01/01/460f6b56bf8e/","link":"","permalink":"http://blog.kcaracal.com/1970/01/01/460f6b56bf8e/","excerpt":"","text":"学习过程中需要创建一张含有批量数据的测试表，可以使用高级语言插入，但感觉比较麻烦，搜了搜可以采用SQL函数，直接在命令行页面批量插入。 数据库名为studytest，表名为student：12345678910CREATE DATABASE studytest;use studytest;CREATE TABLE `student` ( `s_id` int(11) NOT NULL AUTO_INCREMENT, `s_name` varchar(100) DEFAULT NULL, `s_age` int(11) DEFAULT NULL, `s_phone` varchar(30) DEFAULT NULL, PRIMARY KEY (`s_id`), KEY `s_name` (`s_name`)) ENGINE=InnoDB, CHARSET=utf8; SQL函数：1234567891011121314-- 定义分界符DELIMITER $$CREATE PROCEDURE insert_student(IN START INT(10),IN max_num INT(10))BEGIN DECLARE i INT DEFAULT START; -- 关闭自动提交 SET autocommit=0; REPEAT SET i=i+1; INSERT INTO student (s_id,s_name,s_age,s_phone) VALUES (i,CONCAT(&#x27;name_&#x27;,i),MOD(i,70),CONCAT(&#x27;phone_&#x27;,i)); UNTIL i=max_num END REPEAT; COMMIT;END $$ 调用该函数：123-- 先把分隔符换回来，方便操作。不换回来也行，就是以后的；都要写成 $$DELIMITER ; $$CALL insert_student(0,100000); 恢复自动提交：MySQL默认开启自动提交。除非显式地开始一个事务，否则每个查询都被当做一个单独的事务自动执行。 1SET autocommit=1; 查看autocommit状态：命令：show variables like ‘autocommit’;结果： PS：也可以直接利用SQL工具，如Navicat创建函数，完成批量插入。详见：mysql使用函数批量插入数据 完成后的student表： 参考博客：mysql使用存储过程&amp;函数实现批量插入MySQL用存储过程与函数批量插入数据MySQL事务autocommit自动提交","categories":[{"name":"SQL","slug":"SQL","permalink":"http://blog.kcaracal.com/categories/SQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://blog.kcaracal.com/tags/SQL/"}]},{"title":"前端Vue整合后端部署页面一片空白","slug":"前端Vue整合后端部署页面一片空白","date":"1970-01-01T00:00:00.000Z","updated":"2020-11-11T14:59:34.000Z","comments":true,"path":"1970/01/01/24442b66eecf/","link":"","permalink":"http://blog.kcaracal.com/1970/01/01/24442b66eecf/","excerpt":"","text":"首先说明不懂前端，仅仅是在学习前后端分离时遇到了问题，说说怎么解决的。 情况是这样的，学习了一个Vue+Springboot前后端分离博客：Vue + Spring Boot 项目实战（一）：项目简介学习到第6节Vue + Spring Boot 项目实战（六）：前端路由与登录拦截器，把前端和后端整合时，出现了问题，访问localhost:8443/blog/login（Note: 我设置了项目路径，即server.servlet.context-path:/blog/）,界面一篇空白。但可以保证，检查敲的代码一点错误没有，操作步骤完全正确。这就尴尬了，几乎不懂前端，全要靠自己排查了。 排查步骤： 首先注意到原博客有一句话：“虽然页面是空白的，但确实是获取到了这个页面”。然后对比我的index.html的F12 Network调试页面，发现刺眼的错误：脚本和样式的请求路径是错误的，缺少了/blog/路径。 ) 问题出现：URL请求缺少项目路径。那怎么才能能配置路径，让URL请求再加上一个项目路径”/blog/“呢？ 解决办法： 参考博客#为什么vue+webpack需要用到node，如何部署项目到服务器？、知乎vuejs怎么在服务器部署？（主要参考papersnake的回答）、官方配置文档配置参考、API 参考。（顺嘴说一句，在什么不懂的前提下，与其乱百度，倒不如直接看官网，这更像是正确的学习方式）。 首先配置index.html中的js、css等资源路径，这个相关的配置是前端项目config/index.js中，build下的assetsPublicPath。需要改成assetsPublicPath: &#39;./&#39;或者assetsPublicPath: &#39;/blog/&#39;。下图是官方配置参考文档（我的vue是Version 2.x，官方提供的好像是Version 3.x的文档，虽然属性名字有差别，但感觉指的是一个东西，如有不对，请指正哈！）。 然后，配置前端项目router/index.js的Router，添加base:/blog/，这个的目的是告知router项目路径，即请求前缀。没有这一个，前端不能正确识别请求，即/blog/login会无法识别。配个官方配置API 参考截图：这个一定要配置，如果不配置，则访问/blog/login还是空白，后端并没有把404转到index.html资源。 注意：第一步中有个黄色的特别说明，当使用history路由方式时，尽量避免想对路径，即避免assetsPublicPath: &#39;./&#39;，即应该配置为：assetsPublicPath: &#39;/blog/&#39;。如果疏忽了，在history模式下使用./相对路径的方式，会有什么后果呢？（因为粗心大意，没有按官方要求设置，出现了错误，却因祸得福让我注意到了这一点。）给大家截个图：(前提：上面两个配置均操作完成。)可以发现history模式下使用想对publicPath的后果是，部分资源请求路径发送错误。 到这一步，/blog/index.html页面虽然还是空白，但是该拿到的资源就都拿到了。 配置完这两项后，再访问localhost:8443/blog/login，就能看到页面了呦！ 总结：关键两步：1. 配置是前端项目config/index.js中，build下的assetsPublicPath；2. 配置前端项目router/index.js的Router，添加base:/blog/，blog是你的项目名称","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/categories/Java-Web/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://blog.kcaracal.com/tags/Vue/"}]},{"title":"Tomcat零碎收集","slug":"关于Tomcat的零碎收集","date":"1970-01-01T00:00:00.000Z","updated":"2020-11-11T14:47:56.000Z","comments":true,"path":"1970/01/01/d3b22955d537/","link":"","permalink":"http://blog.kcaracal.com/1970/01/01/d3b22955d537/","excerpt":"","text":"问题: 1. **Tomcat是什么？** 2. **Tomcat、Apache、Nginx都是啥关系？** 3. **Tomcat目录及说明** 4. **Tomcat基本框架** 5. **tomcat文件解释：server.xml、web.xml** 简单解答： 1. **Tomcat是什么？** Tomcat是一种轻量级应用服务器，是一个独立的Servlet、JSP的容器，能够处理动态资源，也提供一些web服务器的功能，能够处理静态资源请求。经常搭配Apache/Nginx做动态资源/静态资源分开处理，搭配Nginx做负载均衡。 2. **Tomcat、Apache、Nginx都是啥关系？** Apache是纯粹的web/http服务器，只能处理静态资源，Nginx也可以作为web/http服务器，但除此之外也提供负载均衡功能。参考1：WEB服务器、应用程序服务器、HTTP服务器区别。参考2：apache、node.js、nginx、tomcat谁能帮我捋一捋关系？ 3. **Tomcat目录及说明** /bin - 启动，关闭和其他脚本。 /conf - 配置文件和相关的 DTD。这里最重要的文件是 server.xml。它是容器的主要配置文件。 /lib - 用来存放 tomcat 运行需要加载的 jar 包。 /logs - 日志文件目录。 /webapps - 存放 Web 应用程序的目录。 /work - 部署 Web 应用程序的临时工作目录。 /temp - 运行时产生的临时文件。 Tomcat基本框架 如上图，Tomcat可以按功能划分许多不同的组件，这些组件都可以通过/conf/server.xml文件中可定义和配置，包括Server, Service, Connector, Engine, Cluster, Host, Alias, Context, Realm, Valve, Manager, Listener, Resources, ResourceEnvRef, WatchedResource, Store, Transaction, Channel, Membership, Transport, Member, ClusterListener等，一般可分为以下四类：1、顶级组件：位于配置层次的顶级，并且彼此间有着严格的对应关系，有Server组件、Service组件； 2、连接器：连接客户端（可以是浏览器或Web服务器）请求至Servlet容器，只有Connector组件， 3、容器：表示其功能是处理传入请求的组件，并创建相应的响应。如Engine处理对一个Service的所有请求，Host处理对特定虚拟主机的所有请求，并且Context处理对特定web应用的所有请求； 4、被嵌套的组件：位于一个容器当中，但不能包含其它组件；一些组件可以嵌套在任何Container中，而另一些只能嵌套在Context中。 参考：Tomcat(一) Tomcat是什么：Tomcat与Java技术 Tomcat与Web应用 以及 Tomcat基本框架及相关配置 tomcat文件解释：server.xml、web.xml server.xml： Tomcat核心配置文件，包含Service, Connector, Engine, Realm, Valve, Hosts主组件的相关配置信息。如server.xml默认配置（删除注释内容）如下： web.xml：为部署与Tomcat实例上的所有web应用程序提供部署描述符，通常用于为webapp提供默认的servlet定义和基本的MUIME映射表。 tomcat的web.xml写入的都是web的默认配置，自定义配置需要在web项目的web.xml中设置。参考链接：tomcat下的web.xml和项目中的web.xml","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/categories/Java-Web/"}],"tags":[{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/tags/Java-Web/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://blog.kcaracal.com/tags/Tomcat/"}]},{"title":"小记——Shiro","slug":"小记shiro","date":"1970-01-01T00:00:00.000Z","updated":"2020-11-11T15:02:43.000Z","comments":true,"path":"1970/01/01/aa242fc72c41/","link":"","permalink":"http://blog.kcaracal.com/1970/01/01/aa242fc72c41/","excerpt":"","text":"shiro架构参考# Apache Shiro系列四，概述 —— Shiro的架构 shiro相关教程：Shiro教程安排","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/categories/Java-Web/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://blog.kcaracal.com/tags/Shiro/"}]},{"title":"小记——根据用户动态加载菜单","slug":"小记——根据用户动态加载菜单","date":"1970-01-01T00:00:00.000Z","updated":"2020-11-11T15:00:42.000Z","comments":true,"path":"1970/01/01/65f2cba470ab/","link":"","permalink":"http://blog.kcaracal.com/1970/01/01/65f2cba470ab/","excerpt":"","text":"引用博客：Vue + Spring Boot 项目实战（十五）：动态加载后台菜单 不同用户登录后菜单显示不同的实现，需要同时结合前端和后端。后端主要实现：1. 数据库设计用户可以访问的菜单列表。2. 接收url请求，查询数据库返回允许的菜单列表。前端主要实现：1. Vuex Store添加菜单数组，保存允许访问的菜单项。2. 配置路由，包括Router入口、利用前置守卫添加菜单项路由。 3. 编写前端界面。 后端： 数据库设计用户可以访问的菜单列表：访问控制采用RBAC，数据库涉及的表包括用户表user、角色表role、菜单表menu、用户-角色映射表user_role、角色-菜单映射表role_menu。sql文件链接是：blog.sql这5个表的表属性及内容截图： 后端接收url请求，查询数据库返回允许的菜单列表。需要设计menuService以及menuController，当接收&quot;api/menu&quot;请求后，从数据库中查询当前用户可以访问菜单列表，并返回给前端。注意：本文使用的ORM框架为Mybatis-Plus，相关CRUD请访问官网：CRUD 接口、条件构造器 IMenuService:123public interface IMenuService extends IService&lt;Menu&gt; &#123; public List&lt;Menu&gt; getMenuByCurrentUser();&#125;menuServiceImpl：代码逻辑是：先根据当前用户查询对应的角色，再根据角色查询允许的菜单项。123456789101112131415161718192021222324252627282930313233343536373839404142@Transactional@Servicepublic class MenuServiceImpl extends ServiceImpl&lt;MenuMapper, Menu&gt; implements IMenuService &#123; @Autowired IUserService userService; @Autowired IUserRoleService userRoleService; @Autowired IRoleMenuService roleMenuService; @Override public List&lt;Menu&gt; getMenuByCurrentUser() &#123; // 获取当前用户 String username = SecurityUtils.getSubject().getPrincipal().toString(); User user = userService.getUser(username); System.out.println(&quot;CurrentUser:&quot; + username); // 查询UserRole表, 找到用户对应的role id列表 LambdaQueryWrapper&lt;UserRole&gt; query = Wrappers.&lt;UserRole&gt;lambdaQuery().eq(UserRole::getUid, user.getId()); List&lt;Integer&gt; rids = userRoleService.list(query).stream().map(UserRole::getRid).collect(Collectors.toList()); // 找出这些角色对应的菜单项 LambdaQueryWrapper&lt;RoleMenu&gt; query2 = Wrappers.&lt;RoleMenu&gt;lambdaQuery().in(RoleMenu::getRid, rids); List&lt;Integer&gt; menuIds = roleMenuService.list(query2).stream().map(RoleMenu::getMid).collect(Collectors.toList()); List&lt;Menu&gt; menus = listByIds(menuIds).stream().distinct().collect(Collectors.toList()); //处理菜单项的结构 handleMenus(menus); return menus; &#125; public void handleMenus(List&lt;Menu&gt; menus) &#123; menus.forEach(menu -&gt; &#123;// LambdaQueryWrapper&lt;Menu&gt; query = Wrappers.&lt;Menu&gt;lambdaQuery().eq(Menu::getParentId, menu.getId());// List&lt;Menu&gt; children = list(query); List&lt;Menu&gt; children = menus.stream().filter(m -&gt; m.getParentId() == menu.getId()).collect(Collectors.toList()); menu.setChildren(children); &#125;); // 只是移除显示上的层次关系，但内部多级层次关系并没有删除 menus.removeIf(m -&gt; m.getParentId() != 0); &#125;&#125;menuController:1234567891011@RestControllerpublic class MenuController &#123; @Autowired IMenuService menuService; @GetMapping(&quot;/api/menu&quot;) public List&lt;Menu&gt; menu() &#123; return menuService.getMenuByCurrentUser(); &#125;&#125; 前端： Vuex Store添加菜单数组，保存允许访问的菜单项。1234567891011121314151617181920212223 export default new Vuex.Store(&#123; state: &#123; user: &#123; username: window.localStorage.getItem(&#x27;user&#x27; || &#x27;[]&#x27;) == null ? &#x27;&#x27; : JSON.parse(window.localStorage.getItem(&#x27;user&#x27; || &#x27;[]&#x27;)).username &#125;, // 新增的用来保存可访问菜单项的数组 adminMenus: [] &#125;, mutations: &#123; login (state, user) &#123; state.user = &#123;username: user.username&#125; window.localStorage.setItem(&#x27;user&#x27;, JSON.stringify(user)) &#125;, logout (state) &#123; state.user = [] window.localStorage.removeItem(&#x27;user&#x27;) &#125;, // 新增的菜单数组驱动 initMenu (state, menus) &#123; state.adminMenus = menus &#125; &#125;&#125;) 配置路由，包括Router入口、利用前置守卫添加菜单项路由 首先配置router下的index.js，新增&#39;/admin&#39;路由，作为展示菜单界面的入口。router/index.js:12345678&#123; path: &#x27;/admin&#x27;, name: &#x27;Admin&#x27;, component: AdminIndex, meta: &#123; requireAuth: true &#125; &#125; 利用Vue-Router前置守卫，在真正发出url请求之前初始话菜单，包括1. 将后端返回的菜单项path添加到路由，2. 更新store的adminMenus。这部分代码是在main.js中书写。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475router.beforeEach((to, from, next) =&gt; &#123; if (store.state.user.username &amp;&amp; to.path.startsWith(&#x27;/admin&#x27;)) &#123; // console.log(&#x27;initMenu&#x27;) initMenu(router, store) &#125; // 已登录状态下访问login直接跳转到后台首页 if (store.state.user.username &amp;&amp; to.path.startsWith(&#x27;/login&#x27;)) &#123; next(&#123; path: &#x27;admin/dashboard&#x27; &#125;) &#125;// 登录部分 if (to.meta.requireAuth) &#123; // console.log(store.state.user.username) if (store.state.user) &#123; axios.get(&#x27;/authentication&#x27;) .then(resp =&gt; &#123; if (resp.data) next() // resp.data为空代表后端拦截器判断是未认证、未RememberMe,但这时候依然有resp else &#123; next(&#123; path: &#x27;login&#x27;, // path后缀, 以path?xxx=yyy附加拼接, redirect代表拼接字符xxx, 可以自定义 // 该URL=login?redirect=%2Findex query: &#123;redirect: to.fullPath&#125; &#125;) &#125; &#125;) &#125; else &#123; next(&#123; path: &#x27;login&#x27;, query: &#123;redirect: to.fullPath&#125; &#125;) &#125; &#125; else &#123; next() &#125;&#125;)//初始化菜单const initMenu = (router, store) =&gt; &#123; if (store.state.adminMenus.length &gt; 0) &#123; return &#125; axios.get(&#x27;/menu&#x27;) .then(resp =&gt; &#123; if (resp &amp;&amp; resp.status === 200) &#123; // 把后端返回的菜单列表进行拼接 var fmtRoutes = formatRoutes(resp.data) // 并添加到Router router.addRoutes(fmtRoutes) store.commit(&#x27;initMenu&#x27;, fmtRoutes) &#125; &#125;)&#125;//拼接菜单项路由const formatRoutes = (routes) =&gt; &#123; let fmtRoutes = [] routes.forEach(route =&gt; &#123; if (route.children) &#123; route.children = formatRoutes(route.children) &#125; let fmtRoute = &#123; path: route.path, component: resolve =&gt; &#123; require([&#x27;./components/administration/&#x27; + route.component + &#x27;.vue&#x27;], resolve) &#125;, name: route.name, nameZh: route.nameZh, iconCls: route.iconCls, children: route.children &#125; fmtRoutes.push(fmtRoute) &#125;) return fmtRoutes&#125; 编写前端界面。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div&gt; &lt;el-menu :default-active=&quot;currentPath&quot; class=&quot;el-menu-admin&quot; router mode=&quot;vertical&quot; background-color=&quot;#545c64&quot; text-color=&quot;#fff&quot; active-text-color=&quot;#ffd04b&quot; :collapse=&quot;isCollapse&quot;&gt; &lt;div style=&quot;height: 80px;&quot;&gt;&lt;/div&gt; &lt;!--index 没有用但是必需字段且为 string --&gt; &lt;el-submenu v-for=&quot;(item,i) in adminMenus&quot; :key=&quot;i&quot; :index=&quot;(i).toString()&quot; style=&quot;text-align: left&quot;&gt; &lt;span slot=&quot;title&quot; style=&quot;font-size: 17px;&quot;&gt; &lt;i :class=&quot;item.iconCls&quot;&gt;&lt;/i&gt; &#123;&#123; item.nameZh &#125;&#125; &lt;/span&gt; &lt;el-menu-item v-for=&quot;child in item.children&quot; :key=&quot;child.path&quot; :index=&quot;child.path&quot;&gt; &lt;i :class=&quot;child.icon&quot;&gt;&lt;/i&gt; &#123;&#123; child.nameZh &#125;&#125; &lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;AdminMenu&#x27;, data () &#123; return &#123; isCollapse: false &#125; &#125;, computed: &#123; adminMenus () &#123; return this.$store.state.adminMenus &#125;, currentPath () &#123; return this.$route.path &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt; .el-menu-admin &#123; border-radius: 5px; height: 100%; &#125;&lt;/style&gt; 总结步骤：1. 后端设计数据库。2. 后端设计service和controller，接收请求返回当前用户允许的菜单列表。3. 前端设计Vuex.store，新添菜单数组。4. 前端设计Router，包括router/index.js入口路由、main.js中动态添加菜单项路由。 5. 编写Vue组件AdminMenu.vue。","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/categories/Java-Web/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://blog.kcaracal.com/tags/Spring-Boot/"},{"name":"Vue","slug":"Vue","permalink":"http://blog.kcaracal.com/tags/Vue/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/tags/Java-Web/"}]}],"categories":[{"name":"Code","slug":"Code","permalink":"http://blog.kcaracal.com/categories/Code/"},{"name":"Docker","slug":"Docker","permalink":"http://blog.kcaracal.com/categories/Docker/"},{"name":"Concurrency","slug":"Concurrency","permalink":"http://blog.kcaracal.com/categories/Concurrency/"},{"name":"Misc","slug":"Misc","permalink":"http://blog.kcaracal.com/categories/Misc/"},{"name":"hexo","slug":"hexo","permalink":"http://blog.kcaracal.com/categories/hexo/"},{"name":"Deepin","slug":"Deepin","permalink":"http://blog.kcaracal.com/categories/Deepin/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/categories/Java-Web/"},{"name":"Java","slug":"Java","permalink":"http://blog.kcaracal.com/categories/Java/"},{"name":"Shell","slug":"Shell","permalink":"http://blog.kcaracal.com/categories/Shell/"},{"name":"SQL","slug":"SQL","permalink":"http://blog.kcaracal.com/categories/SQL/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://blog.kcaracal.com/tags/Code/"},{"name":"Docker","slug":"Docker","permalink":"http://blog.kcaracal.com/tags/Docker/"},{"name":"Python","slug":"Python","permalink":"http://blog.kcaracal.com/tags/Python/"},{"name":"Concurrency","slug":"Concurrency","permalink":"http://blog.kcaracal.com/tags/Concurrency/"},{"name":"hexo","slug":"hexo","permalink":"http://blog.kcaracal.com/tags/hexo/"},{"name":"Deepin","slug":"Deepin","permalink":"http://blog.kcaracal.com/tags/Deepin/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://blog.kcaracal.com/tags/Spring-Boot/"},{"name":"Vue","slug":"Vue","permalink":"http://blog.kcaracal.com/tags/Vue/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://blog.kcaracal.com/tags/Java-Web/"},{"name":"Java","slug":"Java","permalink":"http://blog.kcaracal.com/tags/Java/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kcaracal.com/tags/Linux/"},{"name":"Mybatis-Plus","slug":"Mybatis-Plus","permalink":"http://blog.kcaracal.com/tags/Mybatis-Plus/"},{"name":"Mininet","slug":"Mininet","permalink":"http://blog.kcaracal.com/tags/Mininet/"},{"name":"Shell","slug":"Shell","permalink":"http://blog.kcaracal.com/tags/Shell/"},{"name":"SQL","slug":"SQL","permalink":"http://blog.kcaracal.com/tags/SQL/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://blog.kcaracal.com/tags/Tomcat/"},{"name":"Shiro","slug":"Shiro","permalink":"http://blog.kcaracal.com/tags/Shiro/"}]}